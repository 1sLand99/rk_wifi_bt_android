diff --git a/Android.mk b/Android.mk
old mode 100644
new mode 100755
index 29760e4..1ab4b00
--- a/Android.mk
+++ b/Android.mk
@@ -1,5 +1,9 @@
 LOCAL_PATH := $(call my-dir)
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK), true)
+bluetooth_CFLAGS += -DBLUETOOTH_RTK
+bluetooth_CFLAGS += -DBLUETOOTH_RTK_COEX
+endif
 # Setup Bluetooth local make variables for handling configuration
 ifneq ($(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR),)
   bluetooth_C_INCLUDES := $(BOARD_BLUETOOTH_BDROID_BUILDCFG_INCLUDE_DIR)
@@ -9,6 +13,9 @@ else
   bluetooth_CFLAGS += -DHAS_NO_BDROID_BUILDCFG
 endif
 
+bluetooth_C_INCLUDES += $(LOCAL_PATH)
+bluetooth_CFLAGS += -DHAS_BDROID_BUILDCFG
+
 ifneq ($(BOARD_BLUETOOTH_BDROID_HCILP_INCLUDED),)
   bluetooth_CFLAGS += -DHCILP_INCLUDED=$(BOARD_BLUETOOTH_BDROID_HCILP_INCLUDED)
 endif
diff --git a/bta/hh/bta_hh_le.c b/bta/hh/bta_hh_le.c
old mode 100644
new mode 100755
index e6f854f..06cd86a
--- a/bta/hh/bta_hh_le.c
+++ b/bta/hh/bta_hh_le.c
@@ -35,6 +35,9 @@
 #include "srvc_api.h"
 #include "stack/include/l2c_api.h"
 #include "utl.h"
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 
 #ifndef BTA_HH_LE_RECONN
 #define BTA_HH_LE_RECONN    TRUE
@@ -2105,6 +2108,9 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
     UINT8           app_id;
     UINT8           *p_buf;
     tBTA_HH_LE_RPT  *p_rpt;
+#ifdef BLUETOOTH_RTK_COEX
+    UINT8   data_type = 0;
+#endif
 
     if (p_dev_cb == NULL)
     {
@@ -2137,12 +2143,20 @@ void bta_hh_le_input_rpt_notify(tBTA_GATTC_NOTIFY *p_data)
     /* need to append report ID to the head of data */
     if (p_rpt->rpt_id != 0)
     {
+#ifdef BLUETOOTH_RTK_COEX
+        data_type = p_rpt->rpt_id;
+        rtk_parse_manager_get_interface()->rtk_add_le_data_count(data_type);
+#endif
         p_buf = (UINT8 *)osi_malloc(p_data->len + 1);
 
         p_buf[0] = p_rpt->rpt_id;
         memcpy(&p_buf[1], p_data->value, p_data->len);
         ++p_data->len;
     } else {
+#ifdef BLUETOOTH_RTK_COEX
+        data_type = 1;
+        rtk_parse_manager_get_interface()->rtk_add_le_data_count(data_type);
+#endif
         p_buf = p_data->value;
     }
 
diff --git a/btif/src/btif_hh.c b/btif/src/btif_hh.c
old mode 100644
new mode 100755
index 9d883bb..d5a5837
--- a/btif/src/btif_hh.c
+++ b/btif/src/btif_hh.c
@@ -43,6 +43,9 @@
 #include "bt_common.h"
 #include "l2c_api.h"
 #include "osi/include/log.h"
+#ifdef BLUETOOTH_RTK_COEX
+#include "btm_int.h"
+#endif
 
 #define BTIF_HH_APP_ID_MI       0x01
 #define BTIF_HH_APP_ID_KB       0x02
@@ -768,6 +771,23 @@ static void btif_hh_upstreams_evt(UINT16 event, char* p_param)
                     btif_hh_cb.p_curr_dev = btif_hh_find_connected_dev_by_handle(p_data->conn.handle);
                     BTA_HhGetDscpInfo(p_data->conn.handle);
                     p_dev->dev_status = BTHH_CONN_STATE_CONNECTED;
+#ifdef BLUETOOTH_RTK_COEX
+                    tBTM_SEC_DEV_REC *p_dev_rec = btm_find_dev (p_data->conn.bda);
+                    if ((p_dev_rec != NULL) &&((p_dev_rec->device_type &= BT_DEVICE_TYPE_BLE) == 0x02))
+                    {
+                        bt_property_t remote_ble_property;
+                        uint8_t  profile_map =0;
+                        btif_storage_get_remote_device_property((bt_bdaddr_t*)p_data->conn.bda, &remote_ble_property);
+                        if (check_cod((bt_bdaddr_t*)p_data->conn.bda, COD_HID_COMBO))
+                            profile_map |= 0x03;
+                        if (check_cod((bt_bdaddr_t*)p_data->conn.bda, COD_HID_KEYBOARD ))
+                            profile_map |= 0x02;
+                        if (check_cod((bt_bdaddr_t*)p_data->conn.bda, 0x500))
+                            profile_map |= 0x01;
+                        p_dev_rec->profile_map = profile_map;
+                        rtk_parse_manager_get_interface()->rtk_add_le_profile(p_data->conn.bda,  p_dev->dev_handle, profile_map);
+                    }
+#endif
                     HAL_CBACK(bt_hh_callbacks, connection_state_cb,&(p_dev->bd_addr), p_dev->dev_status);
                 }
             }
diff --git a/btif/src/btif_media_task.c b/btif/src/btif_media_task.c
old mode 100644
new mode 100755
index 08af577..3e622d5
--- a/btif/src/btif_media_task.c
+++ b/btif/src/btif_media_task.c
@@ -77,7 +77,9 @@
 #include "oi_codec_sbc.h"
 #include "oi_status.h"
 #endif
-
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 #ifdef USE_AUDIO_TRACK
 #include "btif_avrcp_audio_track.h"
 #endif
@@ -155,8 +157,12 @@ enum {
 
 #ifndef BTIF_A2DP_DEFAULT_BITRATE
 /* High quality quality setting @ 44.1 khz */
+#ifdef BLUETOOTH_RTK
+#define BTIF_A2DP_DEFAULT_BITRATE 229
+#else
 #define BTIF_A2DP_DEFAULT_BITRATE 328
 #endif
+#endif
 
 #ifndef BTIF_A2DP_NON_EDR_MAX_RATE
 #define BTIF_A2DP_NON_EDR_MAX_RATE 229
@@ -1849,6 +1855,9 @@ static void btif_media_task_enc_init(BT_HDR *p_msg)
 
     /* Reset entirely the SBC encoder */
     SBC_Encoder_Init(&(btif_media_cb.encoder));
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_manager_get_interface()->rtk_add_bitpool_to_fw(btif_media_cb.encoder.s16BitPool);
+#endif
 
     btif_media_cb.tx_sbc_frames = calculate_max_frames_per_packet();
 
diff --git a/hci/Android.mk b/hci/Android.mk
old mode 100644
new mode 100755
index 24e3d4d..7c19986
--- a/hci/Android.mk
+++ b/hci/Android.mk
@@ -21,6 +21,21 @@ LOCAL_SRC_FILES := \
     src/packet_fragmenter.c \
     src/vendor.c
 
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+LOCAL_CFLAGS += -DBLUETOOTH_RTK
+LOCAL_SRC_FILES += \
+    src/hci_hal_h5.c \
+    src/rtk_btsnoop_net.c \
+    src/bt_list.c \
+    src/bt_skbuff.c \
+    src/hci_h5.c
+endif
+
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK_COEX),true)
+LOCAL_SRC_FILES += \
+    src/rtk_parse.c
+endif
+
 LOCAL_C_INCLUDES += \
     $(LOCAL_PATH)/include \
     $(LOCAL_PATH)/.. \
@@ -37,6 +52,9 @@ ifeq ($(BLUETOOTH_HCI_USE_MCT),true)
 LOCAL_CFLAGS += -DHCI_USE_MCT
 endif
 LOCAL_CFLAGS += $(bluetooth_CFLAGS)
+ifeq ($(BOARD_HAVE_BLUETOOTH_RTK),true)
+LOCAL_CFLAGS += -Wno-unused-function -Wno-unused-variable
+endif
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
 LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
 
diff --git a/hci/include/bt_hci_bdroid.h b/hci/include/bt_hci_bdroid.h
old mode 100644
new mode 100755
index 2a0577b..9ca740f
--- a/hci/include/bt_hci_bdroid.h
+++ b/hci/include/bt_hci_bdroid.h
@@ -111,6 +111,12 @@ typedef struct _hc_buffer_hdr
 **  Extern variables and functions
 ******************************************************************************/
 
+#ifdef BLUETOOTH_RTK
+extern uint8_t h5_log_enable;
+#endif
+#ifdef BLUETOOTH_RTK_COEX
+extern uint8_t coex_log_enable;
+#endif
 /******************************************************************************
 **  Functions
 ******************************************************************************/
diff --git a/hci/include/bt_list.h b/hci/include/bt_list.h
new file mode 100755
index 0000000..cf070d5
--- /dev/null
+++ b/hci/include/bt_list.h
@@ -0,0 +1,168 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_list.h
+*
+*	Abstract:
+*	    To implement list data structure
+*
+*	Major Change History:
+*	      When             Who         What
+*	    --------------------------------------------------------------
+*	    2010-06-04         W.Bi       Created
+*
+*	Notes:
+*
+******************************************************************************/
+
+#ifndef BT_LIST_H
+#define BT_LIST_H
+
+
+
+
+
+/**
+\file  bt_list.h
+\brief  Implement bluetooth list data structure. Has referred to Linux list implementation
+          You could add your new list manipulation here.
+*/
+
+
+/**
+ List entry structure, could be header or node.
+
+                  Prev<-----Header---->Next
+
+Every List has an additional header, and list tail will be list header's previous node.
+You can use list to form a queue or a stack data structure
+queue:
+    ListAddToTail----->LIST_FOR_EACH iterate--->manipulate on the list entry
+Stack:
+    ListAddToHead--- >LIST_FOR_EACH iterate--->manipulate on the list entry
+*/
+
+///RT list structure definition
+typedef struct _RT_LIST_ENTRY {
+    struct _RT_LIST_ENTRY *Next;   ///< Entry's next element
+    struct _RT_LIST_ENTRY *Prev;   ///< Entry's previous element
+} RT_LIST_ENTRY, *PRT_LIST_ENTRY;
+
+///List head would be another name of list entry, and it points to the list header
+typedef RT_LIST_ENTRY       RT_LIST_HEAD, *PRT_LIST_HEAD;
+
+/*----------------------------------------------------------------------------------
+    EXTERNAL FUNCTION
+----------------------------------------------------------------------------------*/
+
+///Initialize a list with its header
+void ListInitializeHeader(PRT_LIST_HEAD ListHead);
+
+/**
+    Add a new entry to the list.
+    Insert a new entry after the specified head. This is good for implementing stacks.
+    \param [IN]        ListNew     <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header after which to add new entry
+*/
+void ListAddToHead(PRT_LIST_ENTRY ListNew, PRT_LIST_HEAD ListHead);
+
+/**
+    Add a new entry to the list.
+    Insert a new entry before the specified head. This is good for implementing queues.
+    \param [IN]        ListNew     <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header before which to add new entry
+*/
+void ListAddToTail(PRT_LIST_ENTRY ListNew, PRT_LIST_HEAD ListHead);
+
+/**
+    Get entry in the head of the list
+     \param [IN ] ListHead    <RT_LIST_ENTRY>                 : List header
+     \return entry in the head , otherwise NULL
+*/
+RT_LIST_ENTRY* ListGetTop(PRT_LIST_HEAD ListHead);
+
+/**
+    Get entry in the tail of the list
+     \param [IN ] ListHead    <RT_LIST_ENTRY>                 : List header
+     \return entry in the tail , otherwise NULL
+*/
+RT_LIST_ENTRY*
+ListGetTail(
+    PRT_LIST_HEAD ListHead
+);
+
+/**
+    Delete entry from the list
+    Note: ListIsEmpty() on this list entry would not return true, since its state is undefined
+    \param [IN] ListToDelete     <RT_LIST_ENTRY>                 : list entry to be deleted
+*/
+void ListDeleteNode(PRT_LIST_ENTRY ListToDelete);
+
+/**
+    Tell whether the list is empty
+    \param [IN] ListHead          <RT_LIST_ENTRY>                 : List header of which to be test
+*/
+unsigned char ListIsEmpty(PRT_LIST_HEAD ListHead);
+
+//EXTERN void ListEmpty(PRT_LIST_HEAD ListHead);
+
+void
+    ListAdd(
+    PRT_LIST_ENTRY New,
+    PRT_LIST_ENTRY Prev,
+    PRT_LIST_ENTRY Next
+    );
+
+/*----------------------------------------------------------------------------------
+    MACRO
+----------------------------------------------------------------------------------*/
+
+/**
+    Macros to iterate over the list.
+    \param _Iter          : struct PRT_LIST_ENTRY type iterator to use as a loop cursor
+    \param _ListHead   : List head of which to be iterated
+*/
+#define LIST_FOR_EACH(_Iter, _ListHead) \
+        for ((_Iter) = (_ListHead)->Next; (_Iter) != (_ListHead); (_Iter) = (_Iter)->Next)
+
+/**
+    Macros to iterate over the list safely against removal of list entry.
+    If you would delete any list entry from the list while iterating the list, should use this macro
+    \param _Iter          : Struct PRT_LIST_ENTRY type iterator to use as a loop cursor
+    \param _Temp       : Another Struct PRT_LIST_ENTRY type to use as a temporary storage
+    \param _ListHead   : List head of which to be iterated
+*/
+#define LIST_FOR_EACH_SAFELY(_Iter, _Temp, _ListHead) \
+        for ((_Iter) = (_ListHead)->Next, (_Temp) = (_Iter)->Next; (_Iter) != (_ListHead);  \
+               (_Iter) = (_Temp), (_Temp) = (_Iter)->Next)
+
+/**
+    Macros to get the struct pointer of this list entry
+    You could make every RT_LIST_ENTRY at the first place of your structure to avoid the macro, which will be dangerouse.
+    Copy from winnt.h.
+    BUG:if offset of field in type larger than 32 bit interger, which is not likely to happen, it will error
+    \param _Ptr               : Struct RT_LIST_ENTRY type pointer
+    \param _Type            : The type of structure in which the RT_LIST_ENTRY embedded in
+    \param _Field            : the name of the RT_LIST_ENTRY within the struct
+*/
+#define LIST_ENTRY(_Ptr, _Type, _Field) ((_Type *)((char *)(_Ptr)-(unsigned long)(&((_Type *)0)->_Field)))
+
+
+#endif /*BT_LIST_H*/
diff --git a/hci/include/bt_skbuff.h b/hci/include/bt_skbuff.h
new file mode 100755
index 0000000..b6bf55f
--- /dev/null
+++ b/hci/include/bt_skbuff.h
@@ -0,0 +1,362 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_skbuff.h
+*
+*	Abstract:
+*	    Data buffer managerment through whole bluetooth stack.
+*
+*	Major Change History:
+*	      When             Who       What
+*	    --------------------------------------------------------------
+*	    2010-06-11       W.Bi     Created.
+*
+*	Notes:
+*	      To reduce memory copy when pass data buffer to other layers,
+*       RTK_BUFFER is designed referring to linux socket buffer.
+*       But I still wonder its effect, since RTK_BUFFER is much bigger
+*       than original data buffer.RTK_BUFFER will reduce its member if
+*       it would not reach what i had expected.
+*
+******************************************************************************/
+
+
+#ifndef BT_SKBUFF_H
+#define BT_SKBUFF_H
+#include "bt_list.h"
+
+#ifndef EXTERN
+#define EXTERN
+#endif
+
+#ifndef IN
+#define IN
+#endif
+
+#ifndef OUT
+#define OUT
+#endif
+/*----------------------------------------------------------------------------------
+    CONSTANT DEFINITION
+----------------------------------------------------------------------------------*/
+#define RTK_CONTEXT_SIZE 12
+
+#define RTB_QUEUE_ID_LENGTH          64
+
+/*----------------------------------------------------------------------------------
+    STRUCTURE DEFINITION
+----------------------------------------------------------------------------------*/
+/**
+    Rtk buffer definition
+      Head -->|<---Data--->|<-----Length------>| <---End
+                     _________________________________
+                    |_____________|___________________|
+                    |<-headroom->|<--RealDataBuffer-->|
+
+    Compared to socket buffer, there exists no tail and end pointer and tailroom as tail is rarely used in bluetooth stack
+    \param List             : List structure used to list same type rtk buffer and manipulate rtk buffer like list.
+    \param Head           : Pointer to truely allocated data buffer. It point to the headroom
+    \param Data           : Pointer to real data buffer.
+    \param Length        : currently data length
+    \param HeadRoom  : Record initialize headroom size.
+    \param RefCount    : Reference count. zero means able to be freed, otherwise somebody is handling it.
+    \param Priv            : Reserved for multi-device support. Record Hci pointer which will handles this packet
+    \param Contest      : Control buffer, put private variables here.
+*/
+typedef struct _RTK_BUFFER
+{
+    RT_LIST_ENTRY List;
+    uint8_t *Head;
+    uint8_t *Data;
+    uint8_t *Tail;
+    uint8_t *End;
+    uint32_t Length;
+    uint32_t HeadRoom;
+//    RT_U16 TailRoom;
+    signed char   RefCount;
+
+    void* Priv;
+    uint8_t Context[RTK_CONTEXT_SIZE];
+}RTK_BUFFER, *PRTK_BUFFER;
+
+/**
+    RTK_BUFFER Control Buffer Context
+    \param  PacketType      : HCI data types, Command/Acl/...
+    \param  LastFrag          : Is Current Acl buffer the last fragment.(0 for no, 1 for yes)
+    \param  TxSeq             : Current packet tx sequence
+    \param  Retries            : Current packet retransmission times
+    \param  Sar                 : L2cap control field segmentation and reassembly bits
+*/
+struct BT_RTB_CONTEXT{
+    uint8_t   PacketType;
+    uint16_t Handle;
+};
+
+///definition to get rtk_buffer's control buffer context pointer
+#define BT_CONTEXT(_Rtb) ((struct BT_RTB_CONTEXT *)((_Rtb)->Context))
+
+/**
+    Since RTBs are always used into/from list, so abstract this struct and provide APIs to easy process on RTBs
+*/
+typedef struct _RTB_QUEUE_HEAD  RTB_QUEUE_HEAD;
+/*----------------------------------------------------------------------------------
+    EXTERNAL FUNCTION
+----------------------------------------------------------------------------------*/
+/**
+    Allocate a RTK_BUFFER with specified data length and reserved headroom.
+    If caller does not know actual headroom to reserve for further usage, specify it to zero to use default value.
+    \param [IN]     Length            <uint32_t>        : current data buffer length to allcated
+    \param [IN]     HeadRoom     <uint32_t>         : if caller knows reserved head space, set it; otherwise set 0 to use default value
+    \return pointer to RTK_BUFFER if succeed, null otherwise
+*/
+RTK_BUFFER*
+RtbAllocate(
+    IN uint32_t Length,
+    IN uint32_t HeadRoom
+    );
+
+/**
+    Free specified Rtk_buffer
+    \param [IN]     RtkBuffer            <RTK_BUFFER*>        : buffer to free
+*/
+void
+RtbFree(
+    IN RTK_BUFFER* RtkBuffer
+    );
+
+/**
+    increament reference count
+*/
+void
+RtbIncreaseRefCount(
+    IN RTK_BUFFER* RtkBuffer
+);
+
+/**
+    Recycle a rtk_buffer after its usage if specified rtb could
+    if rtb total length is not smaller than specified rtbsize to be recycled for, it will succeeded recycling
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : buffer to recycle
+    \param [IN]             RtbSize              <uint32_t>                 : size of buffer to be recycled for
+*/
+/*
+BOOLEAN
+RtbCheckRecycle(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t   RtbSize
+    );
+*/
+/**
+    Add a specified length protocal header to the start of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer start.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+uint8_t*
+RtbAddHead(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t                 Length
+    );
+
+/**
+    Remove a specified length data from the start of data buffer hold by specified rtk_buffer.
+    This function returns the memory to the headroom.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to remove
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the next data in the buffer is returned, usually useless
+*/
+unsigned char
+RtbRemoveHead(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t                 Length
+    );
+
+/**
+    Add a specified length protocal header to the end of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer end.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+EXTERN uint8_t*
+RtbAddTail(
+    IN OUT RTK_BUFFER* RtkBuffer,
+    IN uint32_t                 Length
+    );
+
+/**
+    Remove a specified length data from the end of data buffer hold by specified rtk_buffer.
+*/
+EXTERN unsigned char
+RtbRemoveTail(
+    IN OUT RTK_BUFFER * RtkBuffer,
+    IN     uint32_t       Length
+);
+
+/**
+    Initialize a rtb queue.
+    \return  Initilized rtb queue if succeed, otherwise NULL
+*/
+EXTERN RTB_QUEUE_HEAD*
+RtbQueueInit(
+    );
+
+/**
+    Free a rtb queue.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+EXTERN void
+RtbQueueFree(
+    RTB_QUEUE_HEAD* RtkQueueHead
+    );
+/**
+    Queue specified RtkBuffer into a RtkQueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+EXTERN void
+RtbQueueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    );
+
+/**
+    Queue specified RtkBuffer into a RtkQueue at list Head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+EXTERN void
+RtbQueueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    );
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+EXTERN RTK_BUFFER*
+RtbDequeueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+EXTERN RTK_BUFFER*
+RtbDequeueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Get current rtb queue's length.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    current queue's length
+*/
+EXTERN signed long
+RtbGetQueueLen(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Empty the rtkqueue.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+EXTERN void
+RtbEmptyQueue(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    );
+
+/**
+    Get the RtkBuffer which is the head of a RtkQueue
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return head of the RtkQueue , otherwise NULL
+*/
+EXTERN RTK_BUFFER*
+RtbTopQueue(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+);
+
+/**
+    Insert new Rtkbuffer in the old buffer
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            OldRtkBuffer                <RTK_BUFFER*>                 : old rtk buffer
+    \param [IN]            NewRtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+EXTERN void
+RtbInsertBefore(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER* pOldRtkBuffer,
+    IN RTK_BUFFER* pNewRtkBuffer
+);
+
+/**
+    check whether the buffer is the last node in the queue
+*/
+EXTERN unsigned char
+RtbNodeIsLast(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+);
+
+/**
+    get the next buffer node after the specified buffer in the queue
+    if the specified buffer is the last node in the queue , return NULL
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk Queue
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk buffer
+    \return node after the specified buffer
+*/
+EXTERN RTK_BUFFER*
+RtbQueueNextNode(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+);
+
+/**
+    check whether queue is empty
+*/
+/*EXTERN BOOLEAN
+RtbQueueIsEmpty(
+   IN RTB_QUEUE_HEAD* RtkQueueHead
+);
+*/
+
+//annie_tmp
+EXTERN unsigned char
+RtbCheckQueueLen(
+   IN RTB_QUEUE_HEAD* RtkQueueHead,
+   IN uint8_t Len
+);
+
+EXTERN void
+RtbRemoveNode(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*         RtkBuffer
+);
+
+EXTERN RTK_BUFFER*
+    RtbCloneBuffer(
+    IN RTK_BUFFER* pDataBuffer
+    );
+
+#endif /*BT_SKBUFF_H*/
diff --git a/hci/include/bt_vendor_lib.h b/hci/include/bt_vendor_lib.h
old mode 100644
new mode 100755
index b4396ea..f6a7256
--- a/hci/include/bt_vendor_lib.h
+++ b/hci/include/bt_vendor_lib.h
@@ -384,8 +384,12 @@ typedef struct {
      * Caller will open the interface and pass in the callback routines
      * to the implemenation of this interface.
      */
-    int   (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr);
 
+#ifdef BLUETOOTH_RTK
+    int (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr, char *bt_device_node);
+#else
+    int (*init)(const bt_vendor_callbacks_t* p_cb, unsigned char *local_bdaddr);
+#endif
     /**  Vendor specific operations */
     int (*op)(bt_vendor_opcode_t opcode, void *param);
 
diff --git a/hci/include/hci_hal.h b/hci/include/hci_hal.h
old mode 100644
new mode 100755
index 93d9a2f..4ef1db2
--- a/hci/include/hci_hal.h
+++ b/hci/include/hci_hal.h
@@ -33,6 +33,7 @@ typedef enum {
 
 typedef void (*data_ready_cb)(serial_data_type_t type);
 
+
 typedef struct {
   // Called when the HAL detects inbound data.
   // Data |type| may be ACL, SCO, or EVENT.
@@ -81,6 +82,9 @@ typedef struct hci_hal_t {
 const hci_hal_t *hci_hal_get_interface(void);
 
 const hci_hal_t *hci_hal_h4_get_interface(void);
+#ifdef BLUETOOTH_RTK
+const hci_hal_t *hci_hal_h5_get_interface(void);
+#endif
 const hci_hal_t *hci_hal_h4_get_test_interface(vendor_t *vendor_interface);
 
 const hci_hal_t *hci_hal_mct_get_interface(void);
diff --git a/hci/include/hci_layer.h b/hci/include/hci_layer.h
old mode 100644
new mode 100755
index 54e1e4a..c5fd7ab
--- a/hci/include/hci_layer.h
+++ b/hci/include/hci_layer.h
@@ -27,6 +27,9 @@
 #include "osi/include/osi.h"
 #include "bt_types.h"
 
+#ifdef BLUETOOTH_RTK
+#include "bt_hci_bdroid.h"
+#endif
 static const char HCI_MODULE[] = "hci_module";
 
 ///// LEGACY DEFINITIONS /////
@@ -73,6 +76,12 @@ typedef enum {
 typedef void (*command_complete_cb)(BT_HDR *response, void *context);
 typedef void (*command_status_cb)(uint8_t status, BT_HDR *command, void *context);
 
+#ifdef BLUETOOTH_RTK
+extern char bt_hci_device_node[BT_HCI_DEVICE_NODE_MAX_LEN];
+
+extern bool bluetooth_rtk_h5_flag ;//Default Usb H4 Interfcace ,if ture Uart H5 Interface
+#endif
+
 typedef struct hci_t {
   // Send a low power command, if supported and the low power manager is enabled.
   void (*send_low_power_command)(low_power_command_t command);
diff --git a/hci/include/rtk_parse.h b/hci/include/rtk_parse.h
new file mode 100755
index 0000000..5a03655
--- /dev/null
+++ b/hci/include/rtk_parse.h
@@ -0,0 +1,96 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    rtk_parse.h
+*
+*	Abstract:
+*	    Contains wifi-bt coex functions implemented by bluedroid stack
+*
+*	Major Change History:
+*	      When             Who       What
+*	    ---------------------------------------------------------------
+*	    2015-12-15      lamparten   modified
+*	    2014-10-23       kyle_xu    modified
+*
+*	Notes:
+*         This is designed for wifi-bt Coex in Android 6.0.
+*
+******************************************************************************/
+
+
+#ifndef RTK_PARSE_H
+#define RTK_PARSE_H
+
+#pragma once
+
+#include <stdlib.h>
+#include "hci_layer.h"
+#include "bt_types.h"
+#include "buffer_allocator.h"
+#include <string.h>
+#include <string.h>
+#include <strings.h>
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+#define HOST_PROFILE_INFO
+
+/******************************************************************************
+**  Type definitions
+******************************************************************************/
+typedef unsigned char   UINT8;
+#define BD_ADDR_LEN     6                   /* Device address length */
+typedef UINT8 BD_ADDR[BD_ADDR_LEN];         /* Device address */
+typedef void* TRANSAC;
+
+
+/******************************************************************************
+**  Extern variables and functions
+******************************************************************************/
+extern uint8_t coex_log_enable;
+
+/******************************************************************************
+**  Functions
+******************************************************************************/
+typedef struct rtk_parse_manager_t {
+
+    void (*rtk_parse_internal_event_intercept)(uint8_t *p);
+
+    void (*rtk_parse_l2cap_data)(uint8_t *p, uint8_t direction);
+
+    void (*rtk_parse_init)(hci_t *hci_if);
+
+    void (*rtk_parse_cleanup)();
+
+    void (*rtk_parse_command)(uint8_t *p);
+
+    void (*rtk_add_le_profile)(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map);
+
+    void (*rtk_delete_le_profile)(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map);
+
+    void (*rtk_add_le_data_count)(uint8_t data_type);
+
+    void (*rtk_add_bitpool_to_fw)(uint8_t bitpool);
+
+}rtk_parse_manager_t;
+
+const rtk_parse_manager_t *rtk_parse_manager_get_interface();
+
+#endif /*RTK_PARSE_H*/
diff --git a/hci/src/bt_list.c b/hci/src/bt_list.c
new file mode 100755
index 0000000..77227b6
--- /dev/null
+++ b/hci/src/bt_list.c
@@ -0,0 +1,144 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_list.c
+*
+*	Abstract:
+*	    To implement list data structure
+*
+*	Major Change History:
+*	      When             Who         What
+*    	--------------------------------------------------------------
+*	    2010-06-04         W.Bi       Created
+*
+*	Notes:
+*
+******************************************************************************/
+#include "bt_list.h"
+
+//****************************************************************************
+// Structure
+//****************************************************************************
+
+
+//****************************************************************************
+// FUNCTION
+//****************************************************************************
+//Initialize a list with its header
+void ListInitializeHeader(PRT_LIST_HEAD ListHead)
+{
+    ListHead->Next = ListHead;
+    ListHead->Prev = ListHead;
+}
+
+/**
+    Tell whether the list is empty
+    \param [IN] ListHead          <RT_LIST_ENTRY>                 : List header of which to be test
+*/
+unsigned char ListIsEmpty(PRT_LIST_HEAD ListHead)
+{
+    return ListHead->Next == ListHead;
+}
+
+/*
+    Insert a new entry between two known consecutive entries.
+    This is only for internal list manipulation where we know the prev&next entries already
+    @New : New element to be added
+    @Prev: previous element in the list
+    @Next: Next element in the list
+*/
+void
+    ListAdd(
+    PRT_LIST_ENTRY New,
+    PRT_LIST_ENTRY Prev,
+    PRT_LIST_ENTRY Next
+    )
+{
+    Next->Prev = New;
+    New->Next = Next;
+    New->Prev = Prev;
+    Prev->Next = New;
+}
+/**
+    Add a new entry to the list.
+    Insert a new entry after the specified head. This is good for implementing stacks.
+    \param [IN] ListNew            <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header after which to add new entry
+*/
+void
+ListAddToHead(
+    PRT_LIST_ENTRY ListNew,
+    PRT_LIST_HEAD ListHead
+    )
+{
+    ListAdd(ListNew, ListHead, ListHead->Next);
+}
+
+/**
+    Add a new entry to the list.
+    Insert a new entry before the specified head. This is good for implementing queues.
+    \param [IN] ListNew            <RT_LIST_ENTRY>                 : new entry to be added
+    \param [IN OUT] ListHead    <RT_LIST_ENTRY>                 : List header before which to add new entry
+*/
+void
+ListAddToTail(
+    PRT_LIST_ENTRY ListNew,
+    PRT_LIST_HEAD ListHead
+    )
+{
+    ListAdd(ListNew, ListHead->Prev, ListHead);
+}
+
+RT_LIST_ENTRY*
+ListGetTop(
+    PRT_LIST_HEAD ListHead
+)
+{
+
+    if (ListIsEmpty(ListHead))
+        return 0;
+
+    return ListHead->Next;
+}
+
+RT_LIST_ENTRY*
+ListGetTail(
+    PRT_LIST_HEAD ListHead
+)
+{
+    if (ListIsEmpty(ListHead))
+        return 0;
+
+    return ListHead->Prev;
+}
+/**
+    Delete entry from the list
+    Note: ListIsEmpty() on this list entry would not return true, since its state is undefined
+    \param [IN] ListToDelete     <RT_LIST_ENTRY>                 : list entry to be deleted
+*/
+void ListDeleteNode(PRT_LIST_ENTRY ListToDelete)
+{
+//    if (ListToDelete->Next != NULL && ListToDelete->Prev != NULL)
+    {
+        ListToDelete->Next->Prev = ListToDelete->Prev;
+        ListToDelete->Prev->Next = ListToDelete->Next;
+        ListToDelete->Next = ListToDelete->Prev = ListToDelete;
+    }
+}
diff --git a/hci/src/bt_skbuff.c b/hci/src/bt_skbuff.c
new file mode 100755
index 0000000..47d4438
--- /dev/null
+++ b/hci/src/bt_skbuff.c
@@ -0,0 +1,573 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    bt_skbuff.c
+*
+*	Abstract:
+*	    Data buffer managerment through whole bluetooth stack.
+*
+*	Major Change History:
+*	      When             Who       What
+*	    --------------------------------------------------------------
+*	    2010-06-11       W.Bi    Created.
+*
+*	Notes:
+*		  To reduce memory copy when pass data buffer to other layers,
+*      	RTK_BUFFER is designed referring to linux socket buffer.
+*       But I still wonder its effect, since RTK_BUFFER is much bigger
+*       than original data buffer.RTK_BUFFER will reduce its member if
+*       it would not reach what i had expected.
+*
+******************************************************************************/
+
+
+#define LOG_TAG "bt_h5"
+#undef NDEBUG
+#include <utils/Log.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+#include <termios.h>
+#include <errno.h>
+#include <pthread.h>
+
+
+#include "bt_list.h"
+#include "bt_skbuff.h"
+#include "bt_types.h"
+#include "string.h"
+#define IN
+#define OUT
+
+//****************************************************************************
+// CONSTANT DEFINITION
+//****************************************************************************
+///default header size
+///l2cap header(8)+hci acl(4)
+#define DEFAULT_HEADER_SIZE    (8+4)
+
+//RTK_BUFFER data buffer alignment
+#define RTB_ALIGN   4
+
+//do alignment with RTB_ALIGN
+#define RTB_DATA_ALIGN(_Length)     ((_Length + (RTB_ALIGN - 1)) & (~(RTB_ALIGN - 1)))
+
+//****************************************************************************
+// STRUCTURE DEFINITION
+//****************************************************************************
+typedef struct _RTB_QUEUE_HEAD{
+    RT_LIST_HEAD List;
+    uint32_t  QueueLen;
+    pthread_mutex_t Lock;
+    uint8_t   Id[RTB_QUEUE_ID_LENGTH];
+}RTB_QUEUE_HEAD, *PRTB_QUEUE_HEAD;
+
+//****************************************************************************
+// FUNCTION
+//****************************************************************************
+/**
+    check whether queue is empty
+    \return :   FALSE   Queue is not empty
+        TRU Queue is empty
+*/
+unsigned char
+RtbQueueIsEmpty(
+   IN RTB_QUEUE_HEAD* RtkQueueHead
+)
+{
+    //return ListIsEmpty(&RtkQueueHead->List);
+    return  RtkQueueHead->QueueLen > 0 ? FALSE : TRUE;
+}
+
+/**
+    Allocate a RTK_BUFFER with specified data length and reserved headroom.
+    If caller does not know actual headroom to reserve for further usage, specify it to zero to use default value.
+    \param [IN]     Length            <uint32_t>        : current data buffer length to allcated
+    \param [IN]     HeadRoom     <uint32_t>         : if caller knows reserved head space, set it; otherwise set 0 to use default value
+    \return pointer to RTK_BUFFER if succeed, null otherwise
+*/
+RTK_BUFFER*
+RtbAllocate(
+    uint32_t Length,
+    uint32_t HeadRoom
+    )
+{
+    RTK_BUFFER* Rtb = NULL;
+    ///Rtb buffer length:
+    ///     RTK_BUFFER   48
+    ///     HeadRoom      HeadRomm or 12
+    ///     Length
+    ///memory size: 48 + Length + 12(default) + 8*2(header for each memory) ---> a multiple of 8
+    ///example:       (48 + 8)+ (300 + 12 + 8) = 372
+    Rtb = malloc( sizeof(RTK_BUFFER) );
+    if(Rtb)
+    {
+        uint32_t BufferLen = HeadRoom ? (Length + HeadRoom) : (Length + DEFAULT_HEADER_SIZE);
+        BufferLen = RTB_DATA_ALIGN(BufferLen);
+        Rtb->Head = malloc(BufferLen);
+        if(Rtb->Head)
+        {
+            Rtb->HeadRoom = HeadRoom ? HeadRoom : DEFAULT_HEADER_SIZE;
+            Rtb->Data = Rtb->Head + Rtb->HeadRoom;
+            Rtb->End = Rtb->Data;
+            Rtb->Tail = Rtb->End + Length;
+            Rtb->Length = 0;
+            ListInitializeHeader(&Rtb->List);
+            Rtb->RefCount = 1;
+            return Rtb;
+        }
+    }
+
+    if (Rtb)
+    {
+        if (Rtb->Head)
+        {
+            free(Rtb->Head);
+        }
+
+        free(Rtb);
+    }
+    return NULL;
+}
+
+
+/**
+    Free specified Rtk_buffer
+    \param [IN]     RtkBuffer            <RTK_BUFFER*>        : buffer to free
+*/
+void
+RtbFree(
+    RTK_BUFFER* RtkBuffer
+)
+{
+    if(RtkBuffer)
+    {
+        free(RtkBuffer->Head);
+        free(RtkBuffer);
+    }
+    return;
+}
+
+/**
+    Add a specified length protocal header to the start of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer start.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+uint8_t*
+RtbAddHead(
+    RTK_BUFFER* RtkBuffer,
+    uint32_t                 Length
+    )
+{
+
+    if ((uint32_t)(RtkBuffer->Data - RtkBuffer->Head) >= Length)
+    {
+        RtkBuffer->Data -= Length;
+        RtkBuffer->Length += Length;
+        RtkBuffer->HeadRoom -= Length;
+        return RtkBuffer->Data;
+    }
+
+    return NULL;
+}
+/**
+    Remove a specified length data from the start of data buffer hold by specified rtk_buffer.
+    This function returns the memory to the headroom.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to remove
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the next data in the buffer is returned, usually useless
+*/
+unsigned char
+RtbRemoveHead(
+    RTK_BUFFER* RtkBuffer,
+    uint32_t                 Length
+    )
+{
+
+    if (RtkBuffer->Length >= Length)
+    {
+        RtkBuffer->Data += Length;
+        RtkBuffer->Length -= Length;
+        RtkBuffer->HeadRoom += Length;
+        return  TRUE;
+    }
+
+    return FALSE;
+}
+
+/**
+    Add a specified length protocal header to the end of data buffer hold by specified rtk_buffer.
+    This function extends used data area of the buffer at the buffer end.
+    \param [IN OUT]     RtkBuffer            <RTK_BUFFER*>        : data buffer to add
+    \param [IN]            Length                <uint32_t>                 : header length
+    \return  Pointer to the first byte of the extra data is returned
+*/
+uint8_t*
+RtbAddTail(
+    RTK_BUFFER* RtkBuffer,
+    uint32_t                 Length
+    )
+{
+
+    if ((uint32_t)(RtkBuffer->Tail - RtkBuffer->End) >= Length)
+    {
+        uint8_t* Tmp = RtkBuffer->End;
+        RtkBuffer->End += Length;
+        RtkBuffer->Length += Length;
+        return Tmp;
+    }
+
+    return NULL;
+}
+
+unsigned char
+RtbRemoveTail(
+    IN OUT RTK_BUFFER * RtkBuffer,
+    IN     uint32_t       Length
+)
+{
+
+    if ((uint32_t)(RtkBuffer->End - RtkBuffer->Data) >= Length)
+    {
+        RtkBuffer->End -= Length;
+        RtkBuffer->Length -= Length;
+        return TRUE;
+    }
+
+    return FALSE;
+}
+//****************************************************************************
+// RTB list manipulation
+//****************************************************************************
+/**
+    Initialize a rtb queue.
+    \return  Initilized rtb queue if succeed, otherwise NULL
+*/
+RTB_QUEUE_HEAD*
+RtbQueueInit(
+)
+{
+    RTB_QUEUE_HEAD* RtbQueue = NULL;
+
+    RtbQueue = malloc(sizeof(RTB_QUEUE_HEAD));
+    if(RtbQueue)
+    {
+        pthread_mutex_init(&RtbQueue->Lock, NULL);
+        ListInitializeHeader(&RtbQueue->List);
+        RtbQueue->QueueLen = 0;
+        return RtbQueue;
+    }
+
+    //error code comes here
+    if (RtbQueue)
+    {
+        free(RtbQueue);
+    }
+    return NULL;
+
+}
+
+/**
+    Free a rtb queue.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+void
+RtbQueueFree(
+    RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    if (RtkQueueHead)
+    {
+
+
+        RtbEmptyQueue(RtkQueueHead);
+        pthread_mutex_destroy(&RtkQueueHead->Lock);
+        free(RtkQueueHead);
+    }
+}
+
+/**
+    Queue specified RtkBuffer into a RtkQueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+void
+RtbQueueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    )
+{
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    ListAddToTail(&RtkBuffer->List, &RtkQueueHead->List);
+    RtkQueueHead->QueueLen++;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+}
+
+/**
+    Queue specified RtkBuffer into a RtkQueue at list Head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+void
+RtbQueueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+    )
+{
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    ListAddToHead(&RtkBuffer->List, &RtkQueueHead->List);
+    RtkQueueHead->QueueLen++;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+}
+
+
+/**
+    Insert new Rtkbuffer in the old buffer
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            OldRtkBuffer                <RTK_BUFFER*>                 : old rtk buffer
+    \param [IN]            NewRtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to add
+*/
+void
+RtbInsertBefore(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*  pOldRtkBuffer,
+    IN RTK_BUFFER*  pNewRtkBuffer
+)
+{
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    ListAdd(&pNewRtkBuffer->List, pOldRtkBuffer->List.Prev, &pOldRtkBuffer->List);
+    RtkQueueHead->QueueLen++;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+}
+
+/**
+    check whether the buffer is the last node in the queue
+*/
+unsigned char
+RtbNodeIsLast(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+)
+{
+    RTK_BUFFER* pBuf;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+    pBuf = (RTK_BUFFER*)RtkQueueHead->List.Prev;
+    if(pBuf == pRtkBuffer)
+    {
+        pthread_mutex_unlock(&RtkQueueHead->Lock);
+        return TRUE;
+    }
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return FALSE;
+}
+
+/**
+    get the next buffer node after the specified buffer in the queue
+    if the specified buffer is the last node in the queue , return NULL
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk Queue
+    \param [IN]     RtkBuffer        <RTK_BUFFER*>        : Rtk buffer
+    \return node after the specified buffer
+*/
+RTK_BUFFER*
+RtbQueueNextNode(
+    IN RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 pRtkBuffer
+)
+{
+    RTK_BUFFER* pBuf;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    pBuf = (RTK_BUFFER*)RtkQueueHead->List.Prev;
+    if(pBuf == pRtkBuffer)
+    {
+        pthread_mutex_unlock(&RtkQueueHead->Lock);
+        return NULL;    ///< if it is already the last node in the queue , return NULL
+    }
+    pBuf = (RTK_BUFFER*)pRtkBuffer->List.Next;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return pBuf;    ///< return next node after this node
+}
+
+/**
+    Delete specified RtkBuffer from a RtkQueue.
+    It don't hold spinlock itself, so caller must hold it at someplace.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \param [IN]            RtkBuffer                <RTK_BUFFER*>                 : Rtk buffer to Remove
+*/
+void
+RtbRemoveNode(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead,
+    IN RTK_BUFFER*                 RtkBuffer
+)
+{
+    RtkQueueHead->QueueLen--;
+    ListDeleteNode(&RtkBuffer->List);
+}
+
+
+/**
+    Get the RtkBuffer which is the head of a RtkQueue
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return head of the RtkQueue , otherwise NULL
+*/
+RTK_BUFFER*
+RtbTopQueue(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+)
+{
+    RTK_BUFFER* Rtb = NULL;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+    if (RtbQueueIsEmpty(RtkQueueHead))
+    {
+        pthread_mutex_unlock(&RtkQueueHead->Lock);
+        return NULL;
+    }
+
+    Rtb = (RTK_BUFFER*)RtkQueueHead->List.Next;
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+
+    return Rtb;
+}
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list tail.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+RTK_BUFFER*
+RtbDequeueTail(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+)
+{
+    RTK_BUFFER* Rtb = NULL;
+
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+    if (RtbQueueIsEmpty(RtkQueueHead))
+    {
+         pthread_mutex_unlock(&RtkQueueHead->Lock);
+         return NULL;
+    }
+    Rtb = (RTK_BUFFER*)RtkQueueHead->List.Prev;
+    RtbRemoveNode(RtkQueueHead, Rtb);
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+
+    return Rtb;
+}
+
+/**
+    Remove a RtkBuffer from specified rtkqueue at list head.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    removed rtkbuffer if succeed, otherwise NULL
+*/
+RTK_BUFFER*
+RtbDequeueHead(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    RTK_BUFFER* Rtb = NULL;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+     if (RtbQueueIsEmpty(RtkQueueHead))
+     {
+         pthread_mutex_unlock(&RtkQueueHead->Lock);
+         return NULL;
+     }
+    Rtb = (RTK_BUFFER*)RtkQueueHead->List.Next;
+    RtbRemoveNode(RtkQueueHead, Rtb);
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return Rtb;
+}
+
+/**
+    Get current rtb queue's length.
+    \param [IN]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+    \return    current queue's length
+*/
+signed long RtbGetQueueLen(
+    IN RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    return RtkQueueHead->QueueLen;
+}
+
+/**
+    Empty the rtkqueue.
+    \param [IN OUT]     RtkQueueHead        <RTB_QUEUE_HEAD*>        : Rtk Queue
+*/
+void
+RtbEmptyQueue(
+    IN OUT RTB_QUEUE_HEAD* RtkQueueHead
+    )
+{
+    RTK_BUFFER* Rtb = NULL;
+    pthread_mutex_lock(&RtkQueueHead->Lock);
+
+    while( !RtbQueueIsEmpty(RtkQueueHead))
+    {
+        Rtb = (RTK_BUFFER*)RtkQueueHead->List.Next;
+        RtbRemoveNode(RtkQueueHead, Rtb);
+        RtbFree(Rtb);
+    }
+
+    pthread_mutex_unlock(&RtkQueueHead->Lock);
+    return;
+}
+
+
+///Annie_tmp
+unsigned char
+RtbCheckQueueLen(IN RTB_QUEUE_HEAD* RtkQueueHead, IN uint8_t Len)
+{
+    return RtkQueueHead->QueueLen < Len ? TRUE : FALSE;
+}
+
+/**
+    clone buffer for upper or lower layer, because original buffer should be stored in l2cap
+    \param <RTK_BUFFER* pDataBuffer: original buffer
+    \return cloned buffer
+*/
+RTK_BUFFER*
+RtbCloneBuffer(
+    IN RTK_BUFFER* pDataBuffer
+)
+{
+    RTK_BUFFER* pNewBuffer = NULL;
+    if(pDataBuffer)
+    {
+        pNewBuffer = RtbAllocate(pDataBuffer->Length,0);
+        if(!pNewBuffer)
+        {
+            return NULL;
+        }
+        if(pDataBuffer && pDataBuffer->Data)
+            memcpy(pNewBuffer->Data, pDataBuffer->Data, pDataBuffer->Length);
+        else
+        {
+            RtbFree(pNewBuffer);
+            return NULL;
+        }
+
+        pNewBuffer->Length = pDataBuffer->Length;
+    }
+    return pNewBuffer;
+}
diff --git a/hci/src/hci_h5.c b/hci/src/hci_h5.c
new file mode 100755
index 0000000..2ba987b
--- /dev/null
+++ b/hci/src/hci_h5.c
@@ -0,0 +1,2976 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*	    hci_h5.c
+*
+*	Abstract:
+*	    Contain HCI transport send/receive functions for UART H5 Interface.
+*
+*	Major Change History:
+*	      When             Who       What
+*	    ---------------------------------------------------------------
+*	    2016-09-23      cc   modified
+*
+*	Notes:
+*	      This is designed for UART H5 HCI Interface in Android 6.0.
+*
+******************************************************************************/
+#define LOG_TAG "bt_h5_int"
+#include <utils/Log.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/prctl.h>
+#include <sys/syscall.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <linux/wait.h>
+
+#include "btsnoop.h"
+#include "hci_hal.h"
+
+#include "hci_h5_int.h"
+#include "bt_skbuff.h"
+#include "bt_list.h"
+#include "bt_hci_bdroid.h"
+#include "hci_layer.h"
+#include "userial.h"
+#include "buffer_allocator.h"
+
+
+/******************************************************************************
+**  Constants & Macros
+******************************************************************************/
+#define H5_TRACE_DATA_ENABLE 0//if you want to see data tx and rx, set H5_TRACE_DATA_ENABLE 1
+#define H5_LOG_VERBOSE      0
+#define H5_BTSNOOP_DUMP     0
+#ifndef RTK_BTSNOOP_NET_DUMP
+#define RTK_BTSNOOP_NET_DUMP    1
+#endif
+
+static const allocator_t *buffer_allocator;
+static const btsnoop_t *btsnoop;
+
+uint8_t h5_log_enable = 0;
+
+#ifndef H5_LOG_BUF_SIZE
+#define H5_LOG_BUF_SIZE  1024
+#endif
+#define H5_LOG_MAX_SIZE  (H5_LOG_BUF_SIZE - 12)
+
+
+#ifndef H5_LOG_BUF_SIZE
+#define H5_LOG_BUF_SIZE  1024
+#endif
+#define H5_LOG_MAX_SIZE  (H5_LOG_BUF_SIZE - 12)
+
+
+#define H5_BTSNOOP_PATCH "/sdcard/h5_btsnoop.cfa"
+
+#define DATA_RETRANS_COUNT  40  //40*100 = 4000ms(4s)
+#define SYNC_RETRANS_COUNT  20  //20*250 = 5000ms(5s)
+#define CONF_RETRANS_COUNT  20
+
+
+#define DATA_RETRANS_TIMEOUT_VALUE  100 //ms
+#define SYNC_RETRANS_TIMEOUT_VALUE   250
+#define CONF_RETRANS_TIMEOUT_VALUE   250
+#define WAIT_CT_BAUDRATE_READY_TIMEOUT_VALUE   250
+#define H5_HW_INIT_READY_TIMEOUT_VALUE   4000//4
+
+#define HCI_VSC_H5_INIT                0xFCEE
+
+
+/* Maximum numbers of allowed internal
+** outstanding command packets at any time
+*/
+#define INT_CMD_PKT_MAX_COUNT       8
+#define INT_CMD_PKT_IDX_MASK        0x07
+
+
+//HCI Event codes
+#define HCI_CONNECTION_COMP_EVT             0x03
+#define HCI_DISCONNECTION_COMP_EVT          0x05
+#define HCI_COMMAND_COMPLETE_EVT    0x0E
+#define HCI_COMMAND_STATUS_EVT      0x0F
+#define HCI_NUM_OF_CMP_PKTS_EVT     0x13
+#define HCI_BLE_EVT     0x3E
+
+
+#define PATCH_DATA_FIELD_MAX_SIZE     252
+#define READ_DATA_SIZE  16
+
+// HCI data types //
+#define H5_RELIABLE_PKT         0x01
+#define H5_UNRELIABLE_PKT       0x00
+
+#define H5_ACK_PKT              0x00
+#define HCI_COMMAND_PKT         0x01
+#define HCI_ACLDATA_PKT         0x02
+#define HCI_SCODATA_PKT         0x03
+#define HCI_EVENT_PKT           0x04
+#define H5_VDRSPEC_PKT          0x0E
+#define H5_LINK_CTL_PKT         0x0F
+
+#define H5_HDR_SEQ(hdr)         ((hdr)[0] & 0x07)
+#define H5_HDR_ACK(hdr)         (((hdr)[0] >> 3) & 0x07)
+#define H5_HDR_CRC(hdr)         (((hdr)[0] >> 6) & 0x01)
+#define H5_HDR_RELIABLE(hdr)    (((hdr)[0] >> 7) & 0x01)
+#define H5_HDR_PKT_TYPE(hdr)    ((hdr)[1] & 0x0f)
+#define H5_HDR_LEN(hdr)         ((((hdr)[1] >> 4) & 0xff) + ((hdr)[2] << 4))
+#define H5_HDR_SIZE             4
+
+#define H5_CFG_SLID_WIN(cfg)    ((cfg) & 0x07)
+#define H5_CFG_OOF_CNTRL(cfg)   (((cfg) >> 3) & 0x01)
+#define H5_CFG_DIC_TYPE(cfg)    (((cfg) >> 4) & 0x01)
+#define H5_CFG_VER_NUM(cfg)     (((cfg) >> 5) & 0x07)
+#define H5_CFG_SIZE             1
+
+
+
+/******************************************************************************
+**  Local type definitions
+******************************************************************************/
+
+static const uint16_t msg_evt_table[] =
+{
+    MSG_HC_TO_STACK_HCI_ERR,       /* H4_TYPE_COMMAND */
+    MSG_HC_TO_STACK_HCI_ACL,       /* H4_TYPE_ACL_DATA */
+    MSG_HC_TO_STACK_HCI_SCO,       /* H4_TYPE_SCO_DATA */
+    MSG_HC_TO_STACK_HCI_EVT        /* H4_TYPE_EVENT */
+};
+
+/* Callback function for the returned event of internal issued command */
+typedef void (*tTIMER_HANDLE_CBACK)(union sigval sigval_value);
+
+typedef struct
+{
+    uint16_t opcode;        /* OPCODE of outstanding internal commands */
+    tINT_CMD_CBACK cback;   /* Callback function when return of internal
+                             * command is received */
+} tINT_CMD_Q;
+
+typedef RTK_BUFFER sk_buff;
+
+typedef enum H5_RX_STATE
+{
+    H5_W4_PKT_DELIMITER,
+    H5_W4_PKT_START,
+    H5_W4_HDR,
+    H5_W4_DATA,
+    H5_W4_CRC
+} tH5_RX_STATE;
+
+typedef enum H5_RX_ESC_STATE
+{
+    H5_ESCSTATE_NOESC,
+    H5_ESCSTATE_ESC
+} tH5_RX_ESC_STATE;
+
+typedef enum H5_LINK_STATE
+{
+    H5_UNINITIALIZED,
+    H5_INITIALIZED,
+    H5_ACTIVE
+} tH5_LINK_STATE;
+
+
+#define H5_EVENT_RX                    0x0001
+#define H5_EVENT_EXIT                  0x0200
+
+static volatile uint8_t h5_retransfer_running = 0;
+static volatile uint16_t h5_ready_events = 0;
+static volatile uint8_t h5_data_ready_running = 0;
+
+
+/* Control block for HCISU_H5 */
+typedef struct HCI_H5_CB
+{
+    HC_BT_HDR   *p_rcv_msg;          /* Buffer to hold current rx HCI message */
+    uint32_t    int_cmd_rsp_pending;        /* Num of internal cmds pending for ack */
+    uint8_t     int_cmd_rd_idx;         /* Read index of int_cmd_opcode queue */
+    uint8_t     int_cmd_wrt_idx;        /* Write index of int_cmd_opcode queue */
+    tINT_CMD_Q  int_cmd[INT_CMD_PKT_MAX_COUNT]; /* FIFO queue */
+
+    tINT_CMD_CBACK cback_h5sync;   /* Callback function when h5 sync*/
+
+    uint8_t     sliding_window_size;
+    uint8_t     oof_flow_control;
+    uint8_t     dic_type;
+
+
+    RTB_QUEUE_HEAD *unack;      // Unack'ed packets queue
+    RTB_QUEUE_HEAD *rel;        // Reliable packets queue
+
+    RTB_QUEUE_HEAD *unrel;      // Unreliable packets queue
+    RTB_QUEUE_HEAD *recv_data;      // Unreliable packets queue
+
+
+    uint8_t     rxseq_txack;        // rxseq == txack. // expected rx SeqNumber
+    uint8_t     rxack;             // Last packet sent by us that the peer ack'ed //
+
+    uint8_t     use_crc;
+    uint8_t     is_txack_req;      // txack required? Do we need to send ack's to the peer? //
+
+    // Reliable packet sequence number - used to assign seq to each rel pkt. */
+    uint8_t     msgq_txseq;         //next pkt seq
+
+    uint16_t    message_crc;
+    uint32_t    rx_count;       //expected pkts to recv
+
+    tH5_RX_STATE        rx_state;
+    tH5_RX_ESC_STATE    rx_esc_state;
+    tH5_LINK_STATE      link_estab_state;
+
+    sk_buff     *rx_skb;
+    sk_buff     *data_skb;
+    sk_buff     *internal_skb;
+
+    timer_t     timer_data_retrans;
+    timer_t     timer_sync_retrans;
+    timer_t     timer_conf_retrans;
+    timer_t     timer_wait_ct_baudrate_ready;
+    timer_t     timer_h5_hw_init_ready;
+
+    uint32_t    data_retrans_count;
+    uint32_t    sync_retrans_count;
+    uint32_t    conf_retrans_count;
+
+    pthread_mutex_t mutex;
+    pthread_cond_t  cond;
+    pthread_t       thread_data_retrans;
+
+    pthread_mutex_t data_mutex;
+    pthread_cond_t  data_cond;
+    pthread_t       thread_data_ready_cb;
+
+    uint8_t     cleanuping;
+}tHCI_H5_CB;
+
+static tHCI_H5_CB rtk_h5;
+static pthread_mutex_t h5_wakeup_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/******************************************************************************
+**  Variables
+******************************************************************************/
+
+/* Num of allowed outstanding HCI CMD packets */
+volatile int num_hci_cmd_pkts = 1;
+extern unsigned int rtkbt_logfilter;
+
+/******************************************************************************
+**  Static variables
+******************************************************************************/
+struct patch_struct {
+    int nTxIndex;   // current sending pkt number
+    int nTotal;     // total pkt number
+    int nRxIndex;   // ack index from board
+    int nNeedRetry; // if no response from board
+};
+static struct patch_struct rtk_patch;
+
+// File descriptor for btsnoop file.
+static int hci_btsnoop_fd = -1;
+// Epoch in microseconds since 01/01/0000.
+static const uint64_t BTSNOOP_EPOCH_DELTA = 0x00dcddb30f2f8000ULL;
+
+/******************************************************************************
+**  Static function
+******************************************************************************/
+static timer_t OsAllocateTimer(tTIMER_HANDLE_CBACK timer_callback);
+static int OsStartTimer(timer_t timerid, int msec, int mode);
+static int OsStopTimer(timer_t timerid);
+static uint16_t h5_wake_up();
+
+static void h5_btsnoop_open(void);
+static void h5_btsnoop_close(void);
+static void h5_btsnoop_cleanup (void);
+static void h5_btsnoop_write(const void *data, size_t length);
+
+static hci_h5_hal_callbacks_t *h5_int_hal_callbacks;
+
+
+/******************************************************************************
+**  Externs
+******************************************************************************/
+extern void rtk_btsnoop_net_open(void);
+extern void rtk_btsnoop_net_close(void);
+extern void rtk_btsnoop_net_write(serial_data_type_t type, uint8_t *data, bool is_received);
+
+uint8_t hci_h5_send_int_cmd(uint16_t opcode, HC_BT_HDR *p_buf, tINT_CMD_CBACK p_cback);
+
+//timer API for retransfer
+int h5_alloc_data_retrans_timer();
+int h5_free_data_retrans_timer();
+int h5_stop_data_retrans_timer();
+int h5_start_data_retrans_timer();
+
+int h5_alloc_sync_retrans_timer();
+int h5_free_sync_retrans_timer();
+int h5_stop_sync_retrans_timer();
+int h5_start_sync_retrans_timer();
+
+int h5_alloc_conf_retrans_timer();
+int h5_free_conf_retrans_timer();
+int h5_stop_conf_retrans_timer();
+int h5_start_conf_retrans_timer();
+
+int h5_alloc_wait_controller_baudrate_ready_timer();
+int h5_free_wait_controller_baudrate_ready_timer();
+int h5_stop_wait_controller_baudrate_ready_timer();
+int h5_start_wait_controller_baudrate_ready_timer();
+
+int h5_alloc_hw_init_ready_timer();
+int h5_free_hw_init_ready_timer();
+int h5_stop_hw_init_ready_timer();
+int h5_start_hw_init_ready_timer();
+
+int h5_enqueue(IN sk_buff *skb);
+
+
+// bite reverse in bytes
+// 00000001 -> 10000000
+// 00000100 -> 00100000
+const uint8_t byte_rev_table[256] = {
+    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
+};
+#ifndef H5_LOG_BUF_SIZE
+#define H5_LOG_BUF_SIZE  1024
+#endif
+#define H5_LOG_MAX_SIZE  (H5_LOG_BUF_SIZE - 12)
+
+#define LOGI0(t,s) __android_log_write(ANDROID_LOG_INFO, t, s)
+
+static void H5LogMsg(const char *fmt_str, ...)
+{
+    static char buffer[H5_LOG_BUF_SIZE];
+    if(h5_log_enable == 1)
+    {
+        va_list ap;
+        va_start(ap, fmt_str);
+        vsnprintf(&buffer[0], H5_LOG_MAX_SIZE, fmt_str, ap);
+        va_end(ap);
+
+        LOGI0("H5: ", buffer);
+     }
+     else
+     {
+        return;
+     }
+}
+
+static void H5LogMsgVerbose(const char *fmt_str, ...)
+{
+    static char buffer[H5_LOG_BUF_SIZE];
+#if H5_LOG_VERBOSE
+    va_list ap;
+    va_start(ap, fmt_str);
+    vsnprintf(&buffer[0], H5_LOG_MAX_SIZE, fmt_str, ap);
+    va_end(ap);
+
+    LOGI0("H5: ", buffer);
+#else
+    return;
+#endif
+}
+
+static uint64_t h5_btsnoop_timestamp(void) {
+  struct timeval tv;
+  gettimeofday(&tv, NULL);
+
+  // Timestamp is in microseconds.
+  uint64_t timestamp = tv.tv_sec * 1000 * 1000LL;
+  timestamp += tv.tv_usec;
+  timestamp += BTSNOOP_EPOCH_DELTA;
+  return timestamp;
+}
+
+static void h5_btsnoop_write_packet(serial_data_type_t type, const uint8_t *packet, bool is_received) {
+    int length_he = 0;
+    int length;
+    int flags;
+    int drops = 0;
+    switch (type) {
+    case HCI_COMMAND_PKT:
+        length_he = packet[2] + 4;
+        flags = 2;
+    break;
+    case HCI_ACLDATA_PKT:
+        length_he = (packet[3] << 8) + packet[2] + 5;
+        flags = is_received;
+    break;
+    case HCI_SCODATA_PKT:
+        length_he = packet[2] + 4;
+        flags = is_received;
+    break;
+    case HCI_EVENT_PKT:
+        length_he = packet[1] + 3;
+        flags = 3;
+    break;
+    default:
+        break;
+    }
+
+    uint64_t timestamp = h5_btsnoop_timestamp();
+    uint32_t time_hi = timestamp >> 32;
+    uint32_t time_lo = timestamp & 0xFFFFFFFF;
+
+    length = htonl(length_he);
+    flags = htonl(flags);
+    drops = htonl(drops);
+    time_hi = htonl(time_hi);
+    time_lo = htonl(time_lo);
+
+    h5_btsnoop_write(&length, 4);
+    h5_btsnoop_write(&length, 4);
+    h5_btsnoop_write(&flags, 4);
+    h5_btsnoop_write(&drops, 4);
+    h5_btsnoop_write(&time_hi, 4);
+    h5_btsnoop_write(&time_lo, 4);
+    h5_btsnoop_write(&type, 1);
+    h5_btsnoop_write(packet, length_he - 1);
+
+}
+
+static void h5_btsnoop_open()
+{
+    if (hci_btsnoop_fd != -1) {
+      LOG_ERROR(LOG_TAG, "%s btsnoop log file is already open.", __func__);
+      return;
+    }
+
+    char fname_backup[266] = {0};
+    strncat(fname_backup, H5_BTSNOOP_PATCH, 255);
+    strcat(fname_backup, ".last");
+    rename(H5_BTSNOOP_PATCH, fname_backup);
+
+
+    hci_btsnoop_fd = open(H5_BTSNOOP_PATCH,
+                          O_WRONLY | O_CREAT | O_TRUNC,
+                          S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
+
+    if (hci_btsnoop_fd == -1) {
+      LOG_ERROR(LOG_TAG, "%s unable to open '%s': %s", __func__, H5_BTSNOOP_PATCH, strerror(errno));
+      return;
+    }
+
+    write(hci_btsnoop_fd, "btsnoop\0\0\0\0\1\0\0\x3\xea", 16);
+}
+
+static void h5_btsnoop_close(void) {
+    if (hci_btsnoop_fd != -1)
+        close(hci_btsnoop_fd);
+    hci_btsnoop_fd = -1;
+}
+
+static void h5_btsnoop_write(const void *data, size_t length) {
+    if (hci_btsnoop_fd != -1)
+        write(hci_btsnoop_fd, data, length);
+}
+
+static void h5_btsnoop_capture(const HC_BT_HDR *p_buf, bool is_rcvd) {
+  const uint8_t *p = (const uint8_t *)(p_buf + 1) + p_buf->offset;
+
+  if (hci_btsnoop_fd == -1)
+    return;
+
+  switch (p_buf->event & MSG_EVT_MASK) {
+    case MSG_HC_TO_STACK_HCI_EVT:
+    if((*(p + 3) == 0x94) && (*(p + 4) == 0xfc) && (*(p + 5) == 0x00)&&(rtkbt_logfilter&1)){}
+    else
+      h5_btsnoop_write_packet(HCI_EVENT_PKT, p, false);
+      break;
+    case MSG_HC_TO_STACK_HCI_ACL:
+    case MSG_STACK_TO_HC_HCI_ACL:
+      h5_btsnoop_write_packet(HCI_ACLDATA_PKT, p, is_rcvd);
+      break;
+    case MSG_HC_TO_STACK_HCI_SCO:
+    case MSG_STACK_TO_HC_HCI_SCO:
+      h5_btsnoop_write_packet(HCI_SCODATA_PKT, p, is_rcvd);
+      break;
+    case MSG_STACK_TO_HC_HCI_CMD:
+      if(((rtkbt_logfilter & 1) == 0) || (*p != 0x94) || (*(p + 1) != 0xfc))
+      h5_btsnoop_write_packet(HCI_COMMAND_PKT, p, true);
+      break;
+  }
+}
+
+// reverse bit
+static __inline uint8_t bit_rev8(uint8_t byte)
+{
+    return byte_rev_table[byte];
+}
+
+// reverse bit
+static __inline uint16_t bit_rev16(uint16_t x)
+{
+    return (bit_rev8(x & 0xff) << 8) | bit_rev8(x >> 8);
+}
+
+static const uint16_t crc_table[] =
+{
+    0x0000, 0x1081, 0x2102, 0x3183,
+    0x4204, 0x5285, 0x6306, 0x7387,
+    0x8408, 0x9489, 0xa50a, 0xb58b,
+    0xc60c, 0xd68d, 0xe70e, 0xf78f
+};
+
+// Initialise the crc calculator
+#define H5_CRC_INIT(x) x = 0xffff
+
+
+/*******************************************************************************
+**
+** Function        ms_delay
+**
+** Description     sleep unconditionally for timeout milliseconds
+**
+** Returns         None
+**
+*******************************************************************************/
+void ms_delay (uint32_t timeout)
+{
+    struct timespec delay;
+    int err;
+
+    if (timeout == 0)
+        return;
+
+    delay.tv_sec = timeout / 1000;
+    delay.tv_nsec = 1000 * 1000 * (timeout%1000);
+
+    /* [u]sleep can't be used because it uses SIGALRM */
+    do {
+        err = nanosleep(&delay, &delay);
+    } while (err < 0 && errno ==EINTR);
+}
+/***********************************************
+//
+//skb related functions
+//
+//
+//
+***********************************************/
+uint8_t *skb_get_data(IN sk_buff *skb)
+{
+    return skb->Data;
+}
+
+uint32_t skb_get_data_length(IN sk_buff *skb)
+{
+    return skb->Length;
+}
+
+sk_buff * skb_alloc(IN unsigned int len)
+{
+    sk_buff * skb = (sk_buff * )RtbAllocate(len, 0);
+    return skb;
+}
+
+void skb_free(IN OUT sk_buff **skb)
+{
+    RtbFree(*skb);
+    *skb = NULL;
+    return;
+}
+
+static  void skb_unlink(sk_buff *skb, struct _RTB_QUEUE_HEAD * list)
+{
+    RtbRemoveNode(list, skb);
+}
+
+// increase the date length in sk_buffer by len,
+// and return the increased header pointer
+uint8_t *skb_put(OUT sk_buff* skb, IN uint32_t len)
+{
+    RTK_BUFFER * rtb = (RTK_BUFFER * )skb;
+
+    return RtbAddTail(rtb, len);
+}
+
+// change skb->len to len
+// !!! len should less than skb->len
+void skb_trim( sk_buff *skb, unsigned int len)
+{
+    RTK_BUFFER * rtb = (RTK_BUFFER * )skb;
+    uint32_t skb_len = skb_get_data_length(skb);
+
+    RtbRemoveTail(rtb, (skb_len - len));
+    return;
+}
+
+uint8_t skb_get_pkt_type( sk_buff *skb)
+{
+    return BT_CONTEXT(skb)->PacketType;
+}
+
+void skb_set_pkt_type( sk_buff *skb, uint8_t pkt_type)
+{
+    BT_CONTEXT(skb)->PacketType = pkt_type;
+}
+
+// decrease the data length in sk_buffer by len,
+// and move the content forward to the header.
+// the data in header will be removed.
+void skb_pull(OUT  sk_buff * skb, IN uint32_t len)
+{
+    RTK_BUFFER * rtb = (RTK_BUFFER * )skb;
+    RtbRemoveHead(rtb, len);
+    return;
+}
+
+sk_buff * skb_alloc_and_init(IN uint8_t PktType, IN uint8_t * Data, IN uint32_t  DataLen)
+{
+    sk_buff * skb = skb_alloc(DataLen);
+    if (NULL == skb)
+    return NULL;
+    memcpy(skb_put(skb, DataLen), Data, DataLen);
+    skb_set_pkt_type(skb, PktType);
+
+    return skb;
+}
+
+static void skb_queue_head(IN RTB_QUEUE_HEAD * skb_head, IN RTK_BUFFER * skb)
+{
+    RtbQueueHead(skb_head, skb);
+}
+
+static void skb_queue_tail(IN RTB_QUEUE_HEAD * skb_head, IN RTK_BUFFER * skb)
+{
+    RtbQueueTail(skb_head, skb);
+}
+
+static RTK_BUFFER* skb_dequeue_head(IN RTB_QUEUE_HEAD * skb_head)
+{
+    return RtbDequeueHead(skb_head);
+}
+
+static RTK_BUFFER* skb_dequeue_tail(IN RTB_QUEUE_HEAD * skb_head)
+{
+    return RtbDequeueTail(skb_head);
+}
+
+static uint32_t skb_queue_get_length(IN RTB_QUEUE_HEAD * skb_head)
+{
+    return RtbGetQueueLen(skb_head);
+}
+
+
+/**
+* Add "d" into crc scope, caculate the new crc value
+*
+* @param crc crc data
+* @param d one byte data
+*/
+static void h5_crc_update(uint16_t *crc, uint8_t d)
+{
+    uint16_t reg = *crc;
+
+    reg = (reg >> 4) ^ crc_table[(reg ^ d) & 0x000f];
+    reg = (reg >> 4) ^ crc_table[(reg ^ (d >> 4)) & 0x000f];
+
+    *crc = reg;
+}
+
+struct __una_u16 { uint16_t x; };
+static __inline uint16_t __get_unaligned_cpu16(const void *p)
+{
+    const struct __una_u16 *ptr = (const struct __una_u16 *)p;
+    return ptr->x;
+}
+
+
+static __inline uint16_t get_unaligned_be16(const void *p)
+{
+    return __get_unaligned_cpu16((const uint8_t *)p);
+}
+/**
+* Get crc data.
+*
+* @param h5 realtek h5 struct
+* @return crc data
+*/
+static uint16_t h5_get_crc(tHCI_H5_CB *h5)
+{
+   uint16_t crc = 0;
+   uint8_t * data = skb_get_data(h5->rx_skb) + skb_get_data_length(h5->rx_skb) - 2;
+   crc = data[1] + (data[0] << 8);
+   return crc;
+}
+
+/**
+* Just add 0xc0 at the end of skb,
+* we can also use this to add 0xc0 at start while there is no data in skb
+*
+* @param skb socket buffer
+*/
+static void h5_slip_msgdelim(sk_buff *skb)
+{
+    const char pkt_delim = 0xc0;
+    memcpy(skb_put(skb, 1), &pkt_delim, 1);
+}
+
+/**
+* Slip ecode one byte in h5 proto, as follows:
+* 0xc0 -> 0xdb, 0xdc
+* 0xdb -> 0xdb, 0xdd
+* 0x11 -> 0xdb, 0xde
+* 0x13 -> 0xdb, 0xdf
+* others will not change
+*
+* @param skb socket buffer
+* @c pure data in the one byte
+*/
+static void h5_slip_one_byte(sk_buff *skb, uint8_t unencode_form)
+{
+    const signed char esc_c0[2] = { 0xdb, 0xdc };
+    const signed char esc_db[2] = { 0xdb, 0xdd };
+    const signed char esc_11[2] = { 0xdb, 0xde };
+    const signed char esc_13[2] = { 0xdb, 0xdf };
+
+    switch (unencode_form)
+    {
+    case 0xc0:
+        memcpy(skb_put(skb, 2), &esc_c0, 2);
+        break;
+    case 0xdb:
+        memcpy(skb_put(skb, 2), &esc_db, 2);
+        break;
+
+    case 0x11:
+    {
+        if(rtk_h5.oof_flow_control)
+        {
+            memcpy(skb_put(skb, 2), &esc_11, 2);
+        }
+        else
+        {
+            memcpy(skb_put(skb, 1), &unencode_form, 1);
+        }
+    }
+    break;
+
+    case 0x13:
+    {
+        if(rtk_h5.oof_flow_control)
+        {
+            memcpy(skb_put(skb, 2), &esc_13, 2);
+        }
+        else
+        {
+            memcpy(skb_put(skb, 1), &unencode_form, 1);
+        }
+    }
+    break;
+
+    default:
+        memcpy(skb_put(skb, 1), &unencode_form, 1);
+    }
+}
+
+/**
+* Decode one byte in h5 proto, as follows:
+* 0xdb, 0xdc -> 0xc0
+* 0xdb, 0xdd -> 0xdb
+* 0xdb, 0xde -> 0x11
+* 0xdb, 0xdf -> 0x13
+* others will not change
+*
+* @param h5 realtek h5 struct
+* @byte pure data in the one byte
+*/
+static void h5_unslip_one_byte(tHCI_H5_CB *h5, unsigned char byte)
+{
+    const uint8_t c0 = 0xc0, db = 0xdb;
+    const uint8_t oof1 = 0x11, oof2 = 0x13;
+    uint8_t *hdr = (uint8_t *)skb_get_data(h5->rx_skb);
+
+    if (H5_ESCSTATE_NOESC == h5->rx_esc_state)
+    {
+        if (0xdb == byte)
+        {
+            h5->rx_esc_state = H5_ESCSTATE_ESC;
+        }
+        else
+        {
+            memcpy(skb_put(h5->rx_skb, 1), &byte, 1);
+            //Check Pkt Header's CRC enable bit
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+            {
+                h5_crc_update(&h5->message_crc, byte);
+            }
+            h5->rx_count--;
+        }
+    }
+    else if(H5_ESCSTATE_ESC == h5->rx_esc_state)
+    {
+        switch (byte)
+        {
+        case 0xdc:
+            memcpy(skb_put(h5->rx_skb, 1), &c0, 1);
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, 0xc0);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        case 0xdd:
+            memcpy(skb_put(h5->rx_skb, 1), &db, 1);
+             if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, 0xdb);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        case 0xde:
+            memcpy(skb_put(h5->rx_skb, 1), &oof1, 1);
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, oof1);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        case 0xdf:
+            memcpy(skb_put(h5->rx_skb, 1), &oof2, 1);
+            if (H5_HDR_CRC(hdr) && h5->rx_state != H5_W4_CRC)
+                h5_crc_update(&h5-> message_crc, oof2);
+            h5->rx_esc_state = H5_ESCSTATE_NOESC;
+            h5->rx_count--;
+            break;
+        default:
+            LOG_ERROR(LOG_TAG, "Error: Invalid byte %02x after esc byte", byte);
+            skb_free(&h5->rx_skb);
+            h5->rx_skb = NULL;
+            h5->rx_state = H5_W4_PKT_DELIMITER;
+            h5->rx_count = 0;
+            break;
+        }
+    }
+}
+/**
+* Prepare h5 packet, packet format as follow:
+*  | LSB 4 octets  | 0 ~4095| 2 MSB
+*  |packet header | payload | data integrity check |
+*
+* pakcket header fromat is show below:
+*  | LSB 3 bits         | 3 bits             | 1 bits                       | 1 bits          |
+*  | 4 bits     | 12 bits        | 8 bits MSB
+*  |sequence number | acknowledgement number | data integrity check present | reliable packet |
+*  |packet type | payload length | header checksum
+*
+* @param h5 realtek h5 struct
+* @param data pure data
+* @param len the length of data
+* @param pkt_type packet type
+* @return socket buff after prepare in h5 proto
+*/
+static sk_buff * h5_prepare_pkt(tHCI_H5_CB *h5, uint8_t *data, signed long len, signed long pkt_type)
+{
+    sk_buff *nskb;
+    uint8_t hdr[4];
+    uint16_t H5_CRC_INIT(h5_txmsg_crc);
+    int rel, i;
+    //H5LogMsg("HCI h5_prepare_pkt");
+
+    switch (pkt_type)
+    {
+    case HCI_ACLDATA_PKT:
+    case HCI_COMMAND_PKT:
+    case HCI_EVENT_PKT:
+    rel = H5_RELIABLE_PKT;  // reliable
+    break;
+    case H5_ACK_PKT:
+    case H5_VDRSPEC_PKT:
+    case H5_LINK_CTL_PKT:
+    rel = H5_UNRELIABLE_PKT;// unreliable
+    break;
+    default:
+    LOG_ERROR(LOG_TAG, "Unknown packet type");
+    return NULL;
+    }
+
+    // Max len of packet: (original len +4(h5 hdr) +2(crc))*2
+    //   (because bytes 0xc0 and 0xdb are escaped, worst case is
+    //   when the packet is all made of 0xc0 and 0xdb :) )
+    //   + 2 (0xc0 delimiters at start and end).
+
+    nskb = skb_alloc((len + 6) * 2 + 2);
+    if (!nskb)
+    {
+        H5LogMsg("nskb is NULL");
+        return NULL;
+    }
+
+    //Add SLIP start byte: 0xc0
+    h5_slip_msgdelim(nskb);
+    // set AckNumber in SlipHeader
+    hdr[0] = h5->rxseq_txack << 3;
+    h5->is_txack_req = 0;
+
+    H5LogMsg("We request packet no(%u) to card", h5->rxseq_txack);
+    H5LogMsg("Sending packet with seqno %u and wait %u", h5->msgq_txseq, h5->rxseq_txack);
+    if (H5_RELIABLE_PKT == rel)
+    {
+        // set reliable pkt bit and SeqNumber
+        hdr[0] |= 0x80 + h5->msgq_txseq;
+        //H5LogMsg("Sending packet with seqno(%u)", h5->msgq_txseq);
+        ++(h5->msgq_txseq);
+        h5->msgq_txseq = (h5->msgq_txseq) & 0x07;
+    }
+
+    // set DicPresent bit
+    if (h5->use_crc)
+    hdr[0] |= 0x40;
+
+    // set packet type and payload length
+    hdr[1] = ((len << 4) & 0xff) | pkt_type;
+    hdr[2] = (uint8_t)(len >> 4);
+    // set checksum
+    hdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);
+
+    // Put h5 header */
+    for (i = 0; i < 4; i++)
+    {
+        h5_slip_one_byte(nskb, hdr[i]);
+
+        if (h5->use_crc)
+            h5_crc_update(&h5_txmsg_crc, hdr[i]);
+    }
+
+    // Put payload */
+    for (i = 0; i < len; i++)
+    {
+        h5_slip_one_byte(nskb, data[i]);
+
+       if (h5->use_crc)
+       h5_crc_update(&h5_txmsg_crc, data[i]);
+    }
+
+    // Put CRC */
+    if (h5->use_crc)
+    {
+        h5_txmsg_crc = bit_rev16(h5_txmsg_crc);
+        h5_slip_one_byte(nskb, (uint8_t) ((h5_txmsg_crc >> 8) & 0x00ff));
+        h5_slip_one_byte(nskb, (uint8_t) (h5_txmsg_crc & 0x00ff));
+    }
+
+    // Add SLIP end byte: 0xc0
+    h5_slip_msgdelim(nskb);
+    return nskb;
+}
+/**
+* Removed controller acked packet from Host's unacked lists
+*
+* @param h5 realtek h5 struct
+*/
+static void h5_remove_acked_pkt(tHCI_H5_CB *h5)
+{
+    RT_LIST_HEAD* Head = NULL;
+    RT_LIST_ENTRY* Iter = NULL, *Temp = NULL;
+    RTK_BUFFER *skb = NULL;
+
+    int pkts_to_be_removed = 0;
+    int seqno = 0;
+    int i = 0;
+
+    pthread_mutex_lock(&h5_wakeup_mutex);
+
+    seqno = h5->msgq_txseq;
+    pkts_to_be_removed = RtbGetQueueLen(h5->unack);
+
+    while (pkts_to_be_removed)
+    {
+        if (h5->rxack == seqno)
+        break;
+
+        pkts_to_be_removed--;
+        seqno = (seqno - 1) & 0x07;
+    }
+
+    if (h5->rxack != seqno)
+    {
+        H5LogMsg("Peer acked invalid packet");
+    }
+
+
+    // remove ack'ed packet from bcsp->unack queue
+    i = 0;//  number of pkts has been removed from un_ack queue.
+    Head = (RT_LIST_HEAD *)(h5->unack);
+    LIST_FOR_EACH_SAFELY(Iter, Temp, Head)
+    {
+        skb = LIST_ENTRY(Iter, sk_buff, List);
+        if (i >= pkts_to_be_removed)
+            break;
+
+        skb_unlink(skb, h5->unack);
+        skb_free(&skb);
+        i++;
+    }
+
+    if (0 == skb_queue_get_length(h5->unack))
+    {
+        h5_stop_data_retrans_timer();
+        rtk_h5.data_retrans_count = 0;
+    }
+
+    if (i != pkts_to_be_removed)
+    {
+        H5LogMsg("Removed only (%u) out of (%u) pkts", i, pkts_to_be_removed);
+    }
+
+    pthread_mutex_unlock(&h5_wakeup_mutex);
+
+}
+
+/**
+* Realtek send pure ack, send a packet only with an ack
+*
+* @param fd uart file descriptor
+*
+*/
+
+static void hci_h5_send_pure_ack(void)
+{
+    //uint16_t bytes_sent = 0;
+    sk_buff * skb = NULL;
+    uint8_t ack_data = 0;
+
+    skb = skb_alloc_and_init(H5_ACK_PKT, &ack_data, 0);
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "skb_alloc_and_init fail!");
+        return;
+    }
+
+    H5LogMsg("H5: --->>>send pure ack");
+    h5_enqueue(skb);
+    h5_wake_up();
+
+#if 0
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, NULL, 0, H5_ACK_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send pure ack");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = h5_int_hal_callbacks->h5_int_transmit_data_cb(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+#endif
+    return;
+
+}
+
+static void hci_h5_send_sync_req()
+{
+    //uint16_t bytes_sent = 0;
+    unsigned char    h5sync[2]     = {0x01, 0x7E};
+    sk_buff * skb = NULL;
+
+    skb = skb_alloc_and_init(H5_LINK_CTL_PKT, h5sync, sizeof(h5sync));
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "skb_alloc_and_init fail!");
+        return;
+    }
+    H5LogMsg("H5: --->>>send sync req");
+
+    h5_enqueue(skb);
+    h5_wake_up();
+#if 0
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5sync, sizeof(h5sync), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send sync req");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = h5_int_hal_callbacks->h5_int_transmit_data_cb(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+#endif
+    return;
+}
+
+static void hci_h5_send_sync_resp()
+{
+    //uint16_t bytes_sent = 0;
+    unsigned char h5syncresp[2] = {0x02, 0x7D};
+    sk_buff * skb = NULL;
+
+    skb = skb_alloc_and_init(H5_LINK_CTL_PKT, h5syncresp, sizeof(h5syncresp));
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "skb_alloc_and_init fail!");
+        return;
+    }
+
+    H5LogMsg("H5: --->>>send sync resp");
+    h5_enqueue(skb);
+    h5_wake_up();
+#if 0
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5syncresp, sizeof(h5syncresp), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send sync resp");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = h5_int_hal_callbacks->h5_int_transmit_data_cb(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+#endif
+    return;
+}
+
+static void hci_h5_send_conf_req()
+{
+    //uint16_t bytes_sent = 0;
+    unsigned char h5conf[3] = {0x03, 0xFC, 0x14};
+    sk_buff * skb = NULL;
+
+    skb = skb_alloc_and_init(H5_LINK_CTL_PKT, h5conf, sizeof(h5conf));
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "skb_alloc_and_init fail!");
+        return;
+    }
+
+    H5LogMsg("H5: --->>>send conf req");
+    h5_enqueue(skb);
+    h5_wake_up();
+
+#if 0
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5conf, sizeof(h5conf), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send conf req");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = h5_int_hal_callbacks->h5_int_transmit_data_cb(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+#endif
+    return;
+}
+
+
+static void hci_h5_send_conf_resp()
+{
+    //uint16_t bytes_sent = 0;
+    unsigned char h5confresp[2] = {0x04, 0x7B};
+    sk_buff * skb = NULL;
+
+    skb = skb_alloc_and_init(H5_LINK_CTL_PKT, h5confresp, sizeof(h5confresp));
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "skb_alloc_and_init fail!");
+        return;
+    }
+
+    H5LogMsg("H5: --->>>send conf resp");
+    h5_enqueue(skb);
+    h5_wake_up();
+#if 0
+    sk_buff *nskb = h5_prepare_pkt(&rtk_h5, h5confresp, sizeof(h5confresp), H5_LINK_CTL_PKT);
+    if(nskb == NULL)
+    {
+        ALOGE("h5_prepare_pkt allocate memory fail");
+        return;
+    }
+    H5LogMsg("H5: --->>>send conf resp");
+    uint8_t * data = skb_get_data(nskb);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 TX: length(%d)", skb_get_data_length(nskb));
+        if(iTempTotal > skb_get_data_length(nskb))
+        {
+            iTempTotal = skb_get_data_length(nskb);
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    bytes_sent = h5_int_hal_callbacks->h5_int_transmit_data_cb(DATA_TYPE_H5, data, skb_get_data_length(nskb));
+    H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+    skb_free(&nskb);
+#endif
+    return;
+}
+
+static void rtk_notify_hw_h5_init_result(uint8_t result)
+{
+    LOG_ERROR(LOG_TAG, "rtk_notify_hw_h5_init_result");
+    uint8_t sync_event[6] = {0x0e, 0x04, 0x03, 0xee, 0xfc, 0x00};
+    // we need to make a sync event to bt
+    sk_buff     *rx_skb;
+    rx_skb = skb_alloc_and_init(HCI_EVENT_PKT, sync_event, sizeof(sync_event));
+
+    pthread_mutex_lock(&rtk_h5.data_mutex);
+    skb_queue_tail(rtk_h5.recv_data, rx_skb);
+    pthread_cond_signal(&rtk_h5.data_cond);
+    pthread_mutex_unlock(&rtk_h5.data_mutex);
+}
+
+
+static sk_buff * h5_dequeue()
+{
+    sk_buff *skb = NULL;
+    //   First of all, check for unreliable messages in the queue,
+    //   since they have higher priority
+    //H5LogMsg("h5_dequeue++");
+    if ((skb = (sk_buff*)skb_dequeue_head(rtk_h5.unrel)) != NULL)
+    {
+        sk_buff *nskb = h5_prepare_pkt(&rtk_h5,
+                                         skb_get_data(skb),
+                                         skb_get_data_length(skb),
+                                         skb_get_pkt_type(skb));
+        if (nskb)
+        {
+            skb_free(&skb);
+            return nskb;
+        }
+        else
+        {
+            skb_queue_head(rtk_h5.unrel, skb);
+        }
+    }
+    //   Now, try to send a reliable pkt. We can only send a
+    //   reliable packet if the number of packets sent but not yet ack'ed
+    //   is < than the winsize
+
+//    H5LogMsg("RtbGetQueueLen(rtk_h5.unack) = (%d), sliding_window_size = (%d)", RtbGetQueueLen(rtk_h5.unack), rtk_h5.sliding_window_size);
+
+    if (RtbGetQueueLen(rtk_h5.unack)< rtk_h5.sliding_window_size &&
+        (skb = (sk_buff *)skb_dequeue_head(rtk_h5.rel)) != NULL)
+    {
+        sk_buff *nskb = h5_prepare_pkt(&rtk_h5,
+                                         skb_get_data(skb),
+                                         skb_get_data_length(skb),
+                                         skb_get_pkt_type(skb));
+        if (nskb)
+        {
+            skb_queue_tail(rtk_h5.unack, skb);
+            h5_start_data_retrans_timer();
+            return nskb;
+        }
+        else
+        {
+            skb_queue_head(rtk_h5.rel, skb);
+        }
+    }
+    //   We could not send a reliable packet, either because there are
+    //   none or because there are too many unack'ed packets. Did we receive
+    //   any packets we have not acknowledged yet
+    if (rtk_h5.is_txack_req)
+    {
+        // if so, craft an empty ACK pkt and send it on BCSP unreliable
+        // channel
+        sk_buff *nskb = h5_prepare_pkt(&rtk_h5, NULL, 0, H5_ACK_PKT);
+        return nskb;
+    }
+    // We have nothing to send
+    return NULL;
+}
+
+int h5_enqueue(IN sk_buff *skb)
+{
+    //Pkt length must be less than 4095 bytes
+    if (skb_get_data_length(skb) > 0xFFF)
+    {
+        LOG_ERROR(LOG_TAG, "skb len > 0xFFF");
+        skb_free(&skb);
+        return 0;
+    }
+
+    switch (skb_get_pkt_type(skb))
+    {
+    case HCI_ACLDATA_PKT:
+    case HCI_COMMAND_PKT:
+        skb_queue_tail(rtk_h5.rel, skb);
+        break;
+
+
+    case H5_LINK_CTL_PKT:
+    case H5_ACK_PKT:
+    case H5_VDRSPEC_PKT:
+        skb_queue_tail(rtk_h5.unrel, skb);/* 3-wire LinkEstablishment*/
+        break;
+    default:
+        skb_free(&skb);
+        break;
+    }
+    return 0;
+}
+
+
+static uint16_t h5_wake_up()
+{
+    uint16_t bytes_sent = 0;
+    sk_buff *skb = NULL;
+    uint8_t * data = NULL;
+    uint32_t data_len = 0;
+
+    pthread_mutex_lock(&h5_wakeup_mutex);
+    //H5LogMsg("h5_wake_up");
+    while (NULL != (skb = h5_dequeue()))
+    {
+        data = skb_get_data(skb);
+        data_len = skb_get_data_length(skb);
+        //we adopt the hci_h5 interface to send data
+        bytes_sent = h5_int_hal_callbacks->h5_int_transmit_data_cb(DATA_TYPE_H5, data, data_len);
+//      bytes_sent = userial_write(0, data, data_len);
+
+        H5LogMsg("bytes_sent(%d)", bytes_sent);
+
+#if H5_TRACE_DATA_ENABLE
+        {
+            uint32_t iTemp = 0;
+            uint32_t iTempTotal = 16;
+            H5LogMsg("H5 TX: length(%d)", data_len);
+            if(iTempTotal > data_len)
+            {
+                iTempTotal = data_len;
+            }
+            for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+            {
+                H5LogMsg("0x%x", data[iTemp]);
+            }
+        }
+#endif
+        skb_free(&skb);
+    }
+
+    pthread_mutex_unlock(&h5_wakeup_mutex);
+    return bytes_sent;
+}
+
+void h5_process_ctl_pkts(void)
+{
+    //process h5 link establish
+    int len;
+    uint8_t cfg;
+
+    tHCI_H5_CB *p_cb = &rtk_h5;
+    sk_buff * skb = rtk_h5.rx_skb;
+
+    unsigned char   h5sync[2]     = {0x01, 0x7E},
+                    h5syncresp[2] = {0x02, 0x7D},
+                    h5conf[3]     = {0x03, 0xFC, 0x14},
+                    h5confresp[2] = {0x04, 0x7B},
+                    h5InitOk[2] = {0xF1, 0xF1};
+
+    //uint8_t *ph5_payload = NULL;
+    //ph5_payload = (uint8_t *)(p_cb->p_rcv_msg + 1);
+
+    if(rtk_h5.link_estab_state == H5_UNINITIALIZED) {  //sync
+        if (!memcmp(skb_get_data(skb), h5sync, 2))
+        {
+            H5LogMsg("H5: <<<---recv sync req");
+            hci_h5_send_sync_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5syncresp, 2))
+        {
+            H5LogMsg("H5: <<<---recv sync resp");
+            h5_stop_sync_retrans_timer();
+            rtk_h5.sync_retrans_count  = 0;
+            rtk_h5.link_estab_state = H5_INITIALIZED;
+
+              //send config req
+              hci_h5_send_conf_req();
+              h5_start_conf_retrans_timer();
+        }
+
+    }
+    else if(rtk_h5.link_estab_state == H5_INITIALIZED) {  //config
+        if (!memcmp(skb_get_data(skb), h5sync, 0x2)) {
+
+            H5LogMsg("H5: <<<---recv sync req in H5_INITIALIZED");
+            hci_h5_send_sync_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5conf, 0x2)) {
+             H5LogMsg("H5: <<<---recv conf req");
+             hci_h5_send_conf_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5confresp,  0x2)) {
+            H5LogMsg("H5: <<<---recv conf resp");
+            h5_stop_conf_retrans_timer();
+            rtk_h5.conf_retrans_count  = 0;
+
+            rtk_h5.link_estab_state = H5_ACTIVE;
+            //notify hw to download patch
+            memcpy(&cfg, skb_get_data(skb)+2, H5_CFG_SIZE);
+            rtk_h5.sliding_window_size = H5_CFG_SLID_WIN(cfg);
+            rtk_h5.oof_flow_control = H5_CFG_OOF_CNTRL(cfg);
+            rtk_h5.dic_type = H5_CFG_DIC_TYPE(cfg);
+            H5LogMsg("rtk_h5.sliding_window_size(%d), oof_flow_control(%d), dic_type(%d)",
+            rtk_h5.sliding_window_size, rtk_h5.oof_flow_control, rtk_h5.dic_type);
+         if(rtk_h5.dic_type)
+            rtk_h5.use_crc = 1;
+
+            rtk_notify_hw_h5_init_result(1);
+        }
+        else {
+            H5LogMsg("H5_INITIALIZED receive event, ingnore");
+        }
+    }
+    else if(rtk_h5.link_estab_state == H5_ACTIVE) {
+        if (!memcmp(skb_get_data(skb), h5sync, 0x2)) {
+
+            H5LogMsg("H5: <<<---recv sync req in H5_ACTIVE");
+            kill(getpid(), SIGKILL);
+            hci_h5_send_sync_resp();
+            H5LogMsg("H5 : H5_ACTIVE transit to H5_UNINITIALIZED");
+            rtk_h5.link_estab_state = H5_UNINITIALIZED;
+            hci_h5_send_sync_req();
+            h5_start_sync_retrans_timer();
+        }
+        else if (!memcmp(skb_get_data(skb), h5conf, 0x2)) {
+             H5LogMsg("H5: <<<---recv conf req in H5_ACTIVE");
+             hci_h5_send_conf_resp();
+        }
+        else if (!memcmp(skb_get_data(skb), h5confresp,  0x2)) {
+            H5LogMsg("H5: <<<---recv conf resp in H5_ACTIVE, discard");
+        }
+        else {
+            H5LogMsg("H5_ACTIVE receive unknown link control msg, ingnore");
+        }
+
+    }
+}
+
+uint8_t isRtkInternalCommand(uint16_t opcode)
+{
+    if(opcode == 0xFC17
+        || opcode == 0xFC6D
+        || opcode == 0xFC61
+        || opcode == 0xFC20)
+    {
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
+
+}
+
+
+/*******************************************************************************
+**
+** Function         internal_event_intercept_h5
+**
+** Description      This function is called to parse received HCI event and
+**                  - update the Num_HCI_Command_Packets
+**                  - intercept the event if it is the result of an early
+**                    issued internal command.
+**
+** Returns          TRUE : if the event had been intercepted for internal process
+**                  FALSE : send this event to core stack
+**
+*******************************************************************************/
+uint8_t internal_event_intercept_h5(void)
+{
+    bool h5_int_command = 0;//if it the H5 int command like H5 vendor cmd or Coex cmd h5_int_command=1;
+    tHCI_H5_CB *p_cb = &rtk_h5;
+    sk_buff * skb = rtk_h5.rx_skb;
+    //uint8_t *ph5_payload = NULL;
+    //ph5_payload = (uint8_t *)(p_cb->p_rcv_msg + 1);
+
+    //process fw change baudrate and patch download
+    uint8_t     *p;
+    uint8_t     event_code;
+    uint16_t    opcode, len;
+    p = (uint8_t *)(p_cb->p_rcv_msg + 1);
+
+    event_code = *p++;
+    len = *p++;
+    H5LogMsg("event_code(0x%x), len = %d", event_code, len);
+    if (event_code == HCI_COMMAND_COMPLETE_EVT)
+    {
+        num_hci_cmd_pkts = *p++;
+        STREAM_TO_UINT16(opcode, p);
+        H5LogMsg("event_code(0x%x)  opcode (0x%x) p_cb->int_cmd_rsp_pending %d", event_code,opcode,p_cb->int_cmd_rsp_pending);
+
+        if (p_cb->int_cmd_rsp_pending > 0)
+        {
+            H5LogMsg("CommandCompleteEvent for command (0x%04X)", opcode);
+            if (opcode == p_cb->int_cmd[p_cb->int_cmd_rd_idx].opcode)
+            {
+                //ONLY HANDLE H5 INIT CMD COMMAND COMPLETE EVT
+                h5_int_command = 1;
+                if(opcode == HCI_VSC_UPDATE_BAUDRATE)
+                {
+                    //need to set a timer, add wait for retransfer packet from controller.
+                    //if there is no packet rx from controller, we can assure baudrate change success.
+                    H5LogMsg("CommandCompleteEvent for command 2 h5_start_wait_controller_baudrate_ready_timer (0x%04X)", opcode);
+                    h5_start_wait_controller_baudrate_ready_timer();
+                }
+                else
+                {
+
+                    if (p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback != NULL)
+                    {
+                        H5LogMsg("CommandCompleteEvent for command (0x%04X) p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback(p_cb->p_rcv_msg)", opcode);
+                        p_cb->int_cmd[p_cb->int_cmd_rd_idx].cback(p_cb->p_rcv_msg);
+                    }
+                    else
+                    {
+                        H5LogMsg("CommandCompleteEvent for command Missing cback function buffer_allocator->free(p_cb->p_rcv_msg) (0x%04X)", opcode);
+                        buffer_allocator->free(p_cb->p_rcv_msg);
+                    }
+                }
+
+                p_cb->int_cmd_rd_idx = ((p_cb->int_cmd_rd_idx+1) & INT_CMD_PKT_IDX_MASK);
+                p_cb->int_cmd_rsp_pending--;
+            }
+        }
+        else {
+            if(opcode == HCI_VSC_UPDATE_BAUDRATE)
+            {
+                h5_int_command |= 0x80;
+                rtk_h5.internal_skb = skb;
+                //need to set a timer, add wait for retransfer packet from controller.
+                //if there is no packet rx from controller, we can assure baudrate change success.
+                H5LogMsg("CommandCompleteEvent for command 2 h5_start_wait_controller_baudrate_ready_timer (0x%04X)", opcode);
+                h5_start_wait_controller_baudrate_ready_timer();
+            }
+        }
+    }
+
+    return h5_int_command;
+
+}
+
+
+/**
+* Check if it's a hci frame, if it is, complete it with response or parse the cmd complete event
+*
+* @param skb socket buffer
+*
+*/
+static uint8_t hci_recv_frame(sk_buff *skb, uint8_t pkt_type)
+{
+    uint8_t intercepted = 0;
+    uint32_t i = 0 ;
+    uint8_t *data = skb_get_data(skb);
+    uint32_t data_len = skb_get_data_length(skb);
+
+    H5LogMsg("UART H5 RX: length = %d", data_len);
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        H5LogMsg("H5 RX: length(%d)", data_len);
+        if(iTempTotal > data_len)
+        {
+            iTempTotal = data_len;
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+    //we only intercept evt packet here
+    if(pkt_type == HCI_EVENT_PKT)
+    {
+        uint8_t     *p;
+        uint8_t     event_code;
+        uint16_t    opcode, len;
+        p = (uint8_t *)skb_get_data(skb);
+
+        event_code = *p++;
+        len = *p++;
+        H5LogMsg("hci_recv_frame event_code(0x%x), len = %d", event_code, len);
+        if (event_code == HCI_COMMAND_COMPLETE_EVT)
+        {
+            num_hci_cmd_pkts = *p++;
+            STREAM_TO_UINT16(opcode, p);
+
+            if(opcode == HCI_VSC_UPDATE_BAUDRATE)
+            {
+                intercepted = 1;
+                rtk_h5.internal_skb = skb;
+                H5LogMsg("CommandCompleteEvent for command h5_start_wait_controller_baudrate_ready_timer (0x%04X)", opcode);
+                h5_start_wait_controller_baudrate_ready_timer();
+            }
+        }
+
+    }
+
+    H5LogMsg("hci_recv_frame intercepted = %d", intercepted);
+    return intercepted;
+}
+
+
+/**
+* after rx data is parsed, and we got a rx frame saved in h5->rx_skb,
+* this routinue is called.
+* things todo in this function:
+* 1. check if it's a hci frame, if it is, complete it with response or ack
+* 2. see the ack number, free acked frame in queue
+* 3. reset h5->rx_state, set rx_skb to null.
+*
+* @param h5 realtek h5 struct
+*
+*/
+static uint8_t h5_complete_rx_pkt(tHCI_H5_CB *h5)
+{
+    int pass_up = 1;
+    uint16_t eventtype = 0;
+    uint8_t *h5_hdr = NULL;
+    uint8_t complete_pkt = TRUE;
+    uint8_t pkt_type = 0;
+    tHCI_H5_CB *p_cb=&rtk_h5;
+    uint8_t status = 0;
+
+    //H5LogMsg("HCI 3wire h5_complete_rx_pkt");
+    h5_hdr = (uint8_t *)skb_get_data(h5->rx_skb);
+    H5LogMsg("SeqNumber(%d), AckNumber(%d)", H5_HDR_SEQ(h5_hdr), H5_HDR_ACK(h5_hdr));
+
+
+#if H5_TRACE_DATA_ENABLE
+    {
+        uint32_t iTemp = 0;
+        uint32_t iTempTotal = 16;
+        uint32_t data_len = skb_get_data_length(h5->rx_skb);
+        uint8_t *data = skb_get_data(h5->rx_skb);
+        H5LogMsg("H5 RX: length(%d)", data_len);
+
+        if(iTempTotal > data_len)
+        {
+            iTempTotal = data_len;
+        }
+        for(iTemp = 0; iTemp < iTempTotal; iTemp++)
+        {
+            H5LogMsg("0x%x", data[iTemp]);
+        }
+    }
+#endif
+
+    if (H5_HDR_RELIABLE(h5_hdr))
+    {
+        H5LogMsg("Received reliable seqno %u from card", h5->rxseq_txack);
+        pthread_mutex_lock(&h5_wakeup_mutex);
+        h5->rxseq_txack = H5_HDR_SEQ(h5_hdr) + 1;
+        h5->rxseq_txack %= 8;
+        h5->is_txack_req = 1;
+        pthread_mutex_unlock(&h5_wakeup_mutex);
+        // send down an empty ack if needed.
+        h5_wake_up();
+    }
+
+    h5->rxack = H5_HDR_ACK(h5_hdr);
+    pkt_type = H5_HDR_PKT_TYPE(h5_hdr);
+    H5LogMsg("h5_complete_rx_pkt, pkt_type = %d", pkt_type);
+    switch (pkt_type)
+    {
+        case HCI_ACLDATA_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_ACL;
+        break;
+
+        case HCI_EVENT_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_EVT;
+            break;
+
+        case HCI_SCODATA_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_SCO;
+            break;
+        case HCI_COMMAND_PKT:
+            pass_up = 1;
+            eventtype = MSG_HC_TO_STACK_HCI_ERR;
+            break;
+
+        case H5_LINK_CTL_PKT:
+            pass_up = 0;
+        break;
+
+        case H5_ACK_PKT:
+            pass_up = 0;
+            break;
+
+        default:
+          LOG_ERROR(LOG_TAG, "Unknown pkt type(%d)", H5_HDR_PKT_TYPE(h5_hdr));
+          eventtype = MSG_HC_TO_STACK_HCI_ERR;
+          pass_up = 0;
+          break;
+    }
+
+    // remove h5 header and send packet to hci
+    h5_remove_acked_pkt(h5);
+
+    if(H5_HDR_PKT_TYPE(h5_hdr) == H5_LINK_CTL_PKT)
+    {
+
+        skb_pull(h5->rx_skb, H5_HDR_SIZE);
+        h5_process_ctl_pkts();
+    }
+
+    // decide if we need to pass up.
+    if (pass_up)
+    {
+        skb_pull(h5->rx_skb, H5_HDR_SIZE);
+        skb_set_pkt_type(h5->rx_skb, pkt_type);
+
+        //send command or  acl data it to bluedroid stack
+        uint16_t len = 0;
+        sk_buff * skb_complete_pkt = h5->rx_skb;
+
+        /* Allocate a buffer for message */
+
+        len = BT_HC_HDR_SIZE + skb_get_data_length(skb_complete_pkt);
+        h5->p_rcv_msg = (HC_BT_HDR *) buffer_allocator->alloc(len);
+
+        if (h5->p_rcv_msg)
+        {
+            /* Initialize buffer with received h5 data */
+            h5->p_rcv_msg->offset = 0;
+            h5->p_rcv_msg->layer_specific = 0;
+            h5->p_rcv_msg->event = eventtype;
+            h5->p_rcv_msg->len = skb_get_data_length(skb_complete_pkt);
+            memcpy((uint8_t *)(h5->p_rcv_msg + 1), skb_get_data(skb_complete_pkt), skb_get_data_length(skb_complete_pkt));
+        }
+
+#if H5_BTSNOOP_DUMP
+        if(h5->p_rcv_msg)
+            h5_btsnoop_capture(h5->p_rcv_msg, TRUE);
+#endif
+
+#if RTK_BTSNOOP_NET_DUMP
+        rtk_btsnoop_net_write(pkt_type, (uint8_t *)(h5->p_rcv_msg + 1), TRUE);
+#endif
+
+        status = hci_recv_frame(skb_complete_pkt, pkt_type);
+
+        if(h5->p_rcv_msg)
+            buffer_allocator->free(h5->p_rcv_msg);
+
+        if(!status) {
+            pthread_mutex_lock(&rtk_h5.data_mutex);
+            skb_queue_tail(rtk_h5.recv_data, h5->rx_skb);
+            pthread_cond_signal(&rtk_h5.data_cond);
+            pthread_mutex_unlock(&rtk_h5.data_mutex);
+        }
+    }
+    else {
+        // free ctl packet
+        skb_free(&h5->rx_skb);
+    }
+    h5->rx_state = H5_W4_PKT_DELIMITER;
+    rtk_h5.rx_skb = NULL;
+    return pkt_type;
+}
+
+
+/**
+* Parse the receive data in h5 proto.
+*
+* @param h5 realtek h5 struct
+* @param data point to data received before parse
+* @param count num of data
+* @return reserved count
+*/
+static BOOLEAN h5_recv(tHCI_H5_CB *h5, uint8_t *data, int count)
+{
+//   unsigned char *ptr;
+    uint8_t *ptr;
+    uint8_t * skb_data = NULL;
+    uint8_t *hdr = NULL;
+    BOOLEAN complete_packet = FALSE;
+
+    ptr = (uint8_t *)data;
+    //H5LogMsg("count %d rx_state %d rx_count %ld", count, h5->rx_state, h5->rx_count);
+    while (count)
+    {
+        if (h5->rx_count)
+        {
+            if (*ptr == 0xc0)
+            {
+                LOG_ERROR(LOG_TAG, "short h5 packet");
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_START;
+                h5->rx_count = 0;
+            } else
+                h5_unslip_one_byte(h5, *ptr);
+
+            ptr++; count--;
+            continue;
+        }
+
+        //H5LogMsg("h5_recv rx_state=%d", h5->rx_state);
+        switch (h5->rx_state)
+        {
+        case H5_W4_HDR:
+            // check header checksum. see Core Spec V4 "3-wire uart" page 67
+            skb_data = skb_get_data(h5->rx_skb);
+            hdr = (uint8_t *)skb_data;
+
+            if ((0xff & (uint8_t) ~ (skb_data[0] + skb_data[1] +
+                                   skb_data[2])) != skb_data[3])
+            {
+                LOG_ERROR(LOG_TAG, "h5 hdr checksum error!!!");
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_DELIMITER;
+                h5->rx_count = 0;
+                continue;
+            }
+
+            if (H5_HDR_RELIABLE(hdr)
+                && (H5_HDR_SEQ(hdr) != h5->rxseq_txack))
+            {
+                LOG_ERROR(LOG_TAG, "Out-of-order packet arrived, got(%u)expected(%u)",
+                   H5_HDR_SEQ(hdr), h5->rxseq_txack);
+                h5->is_txack_req = 1;
+                h5_wake_up();
+
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_DELIMITER;
+                h5->rx_count = 0;
+
+                continue;
+            }
+            h5->rx_state = H5_W4_DATA;
+            //payload length: May be 0
+            h5->rx_count = H5_HDR_LEN(hdr);
+            continue;
+        case H5_W4_DATA:
+            hdr = (uint8_t *)skb_get_data(h5->rx_skb);
+            if (H5_HDR_CRC(hdr))
+            {   // pkt with crc /
+                h5->rx_state = H5_W4_CRC;
+                h5->rx_count = 2;
+            }
+            else
+            {
+                h5_complete_rx_pkt(h5); //Send ACK
+                complete_packet = TRUE;
+                H5LogMsg("--------> H5_W4_DATA ACK\n");
+            }
+            continue;
+
+        case H5_W4_CRC:
+            if (bit_rev16(h5->message_crc) != h5_get_crc(h5))
+            {
+                LOG_ERROR(LOG_TAG, "Checksum failed, computed(%04x)received(%04x)",
+                    bit_rev16(h5->message_crc), h5_get_crc(h5));
+                skb_free(&h5->rx_skb);
+                h5->rx_state = H5_W4_PKT_DELIMITER;
+                h5->rx_count = 0;
+                continue;
+            }
+            skb_trim(h5->rx_skb, skb_get_data_length(h5->rx_skb) - 2);
+            h5_complete_rx_pkt(h5);
+            complete_packet = TRUE;
+            continue;
+
+        case H5_W4_PKT_DELIMITER:
+            switch (*ptr)
+            {
+            case 0xc0:
+                h5->rx_state = H5_W4_PKT_START;
+                break;
+            default:
+                break;
+            }
+            ptr++; count--;
+            break;
+
+        case H5_W4_PKT_START:
+            switch (*ptr)
+            {
+            case 0xc0:
+                ptr++; count--;
+                break;
+            default:
+                h5->rx_state = H5_W4_HDR;
+                h5->rx_count = 4;
+                h5->rx_esc_state = H5_ESCSTATE_NOESC;
+                H5_CRC_INIT(h5->message_crc);
+
+                // Do not increment ptr or decrement count
+                // Allocate packet. Max len of a H5 pkt=
+                // 0xFFF (payload) +4 (header) +2 (crc)
+                h5->rx_skb = skb_alloc(0x1005);
+                if (!h5->rx_skb)
+                {
+                    h5->rx_state = H5_W4_PKT_DELIMITER;
+                    h5->rx_count = 0;
+                    return FALSE;
+                }
+                break;
+            }
+            break;
+        }
+    }
+    return complete_packet;
+}
+
+/******************************************************************************
+**  Static functions
+******************************************************************************/
+static void data_ready_cb_thread(void *arg)
+{
+    sk_buff *skb;
+    uint8_t pkt_type = 0;
+
+    H5LogMsg("data_ready_cb_thread started");
+
+    prctl(PR_SET_NAME, (unsigned long)"data_ready_cb_thread", 0, 0, 0);
+
+    while (h5_data_ready_running)
+    {
+        pthread_mutex_lock(&rtk_h5.data_mutex);
+        while ((skb_queue_get_length(rtk_h5.recv_data) == 0))
+        {
+            pthread_cond_wait(&rtk_h5.data_cond, &rtk_h5.data_mutex);
+        }
+        pthread_mutex_unlock(&rtk_h5.data_mutex);
+
+        if((skb = skb_dequeue_head(rtk_h5.recv_data)) != NULL) {
+            rtk_h5.data_skb = skb;
+        }
+
+        pkt_type = skb_get_pkt_type(rtk_h5.data_skb);
+        h5_int_hal_callbacks->h5_data_ready_cb(pkt_type);
+    }
+
+    H5LogMsg("data_ready_cb_thread exiting");
+    pthread_exit(NULL);
+
+}
+
+static void data_retransfer_thread(void *arg)
+{
+    uint16_t events;
+    uint32_t i = 0;
+
+    H5LogMsg("data_retransfer_thread started");
+
+    prctl(PR_SET_NAME, (unsigned long)"data_retransfer_thread", 0, 0, 0);
+
+    while (h5_retransfer_running)
+    {
+        pthread_mutex_lock(&rtk_h5.mutex);
+        while (h5_ready_events == 0)
+        {
+            pthread_cond_wait(&rtk_h5.cond, &rtk_h5.mutex);
+        }
+        events = h5_ready_events;
+        h5_ready_events = 0;
+        pthread_mutex_unlock(&rtk_h5.mutex);
+
+        if (events & H5_EVENT_RX)
+        {
+            sk_buff *skb;
+            LOG_ERROR(LOG_TAG, "retransmitting (%u) pkts, retransfer count(%d)", skb_queue_get_length(rtk_h5.unack), rtk_h5.data_retrans_count);
+            if(rtk_h5.data_retrans_count < DATA_RETRANS_COUNT)
+            {
+                while ((skb = skb_dequeue_tail(rtk_h5.unack)) != NULL)
+                {
+#if H5_TRACE_DATA_ENABLE
+                    uint32_t data_len = skb_get_data_length(skb);
+                    uint8_t* pdata = skb_get_data(skb);
+                    if(data_len>16)
+                        data_len=16;
+
+                    for(i = 0 ; i < data_len; i++)
+                        ALOGE("0x%02X", pdata[i]);
+#endif
+                    rtk_h5.msgq_txseq = (rtk_h5.msgq_txseq - 1) & 0x07;
+                    skb_queue_head(rtk_h5.rel, skb);
+
+                }
+                rtk_h5.data_retrans_count++;
+                h5_wake_up();
+
+            }
+            else
+            {
+            //do not put packet to rel queue, and do not send
+            //Kill bluetooth
+            kill(getpid(), SIGKILL);
+            }
+
+        }
+        else
+        if (events & H5_EVENT_EXIT)
+        {
+            break;
+        }
+
+}
+
+    H5LogMsg("data_retransfer_thread exiting");
+    pthread_exit(NULL);
+
+}
+
+void h5_retransfer_signal_event(uint16_t event)
+{
+    pthread_mutex_lock(&rtk_h5.mutex);
+    h5_ready_events |= event;
+    pthread_cond_signal(&rtk_h5.cond);
+    pthread_mutex_unlock(&rtk_h5.mutex);
+}
+
+static int create_data_retransfer_thread()
+{
+    struct sched_param param;
+    int policy;
+
+    pthread_attr_t thread_attr;
+
+
+    if (h5_retransfer_running)
+    {
+        ALOGW("create_data_retransfer_thread has been called repeatedly without calling cleanup ?");
+    }
+
+    h5_retransfer_running = 1;
+    h5_ready_events = 0;
+
+    pthread_attr_init(&thread_attr);
+    pthread_mutex_init(&rtk_h5.mutex, NULL);
+    pthread_cond_init(&rtk_h5.cond, NULL);
+
+    if (pthread_create(&rtk_h5.thread_data_retrans, &thread_attr, \
+               (void*)data_retransfer_thread, NULL) != 0)
+    {
+        LOG_ERROR(LOG_TAG, "pthread_create thread_data_retrans failed!");
+        h5_retransfer_running = 0;
+        return -1 ;
+    }
+/*
+    if(pthread_getschedparam(hc_cb.worker_thread, &policy, &param)==0)
+    {
+        policy = BTHC_LINUX_BASE_POLICY;
+
+#if (BTHC_LINUX_BASE_POLICY!=SCHED_NORMAL)
+        param.sched_priority = BTHC_MAIN_THREAD_PRIORITY;
+#endif
+        result = pthread_setschedparam(hc_cb.worker_thread, policy, &param);
+        if (result != 0)
+        {
+            ALOGW("create_data_retransfer_thread pthread_setschedparam failed (%s)", \
+            strerror(result));
+        }
+    }
+*/
+    return 0;
+
+}
+
+
+static int create_data_ready_cb_thread()
+{
+    struct sched_param param;
+    int policy;
+
+    pthread_attr_t thread_attr;
+
+
+    if (h5_data_ready_running)
+    {
+        ALOGW("create_data_ready_cb_thread has been called repeatedly without calling cleanup ?");
+    }
+
+    h5_data_ready_running = 1;
+
+    pthread_attr_init(&thread_attr);
+    pthread_mutex_init(&rtk_h5.data_mutex, NULL);
+    pthread_cond_init(&rtk_h5.data_cond, NULL);
+
+    if (pthread_create(&rtk_h5.thread_data_ready_cb, &thread_attr, \
+               (void*)data_ready_cb_thread, NULL) != 0)
+    {
+        LOG_ERROR(LOG_TAG, "pthread_create thread_data_ready_cb failed!");
+        h5_data_ready_running = 0;
+        return -1 ;
+    }
+    return 0;
+
+}
+
+
+/*****************************************************************************
+**   HCI H5 INTERFACE FUNCTIONS
+*****************************************************************************/
+
+/*******************************************************************************
+**
+** Function        hci_h5_init
+**
+** Description     Initialize H5 module
+**
+** Returns         None
+**
+*******************************************************************************/
+void hci_h5_int_init(hci_h5_hal_callbacks_t* h5_callbacks)
+{
+    H5LogMsg("hci_h5_int_init");
+
+    h5_int_hal_callbacks = h5_callbacks;
+    memset(&rtk_h5, 0, sizeof(tHCI_H5_CB));
+
+
+    /* Per HCI spec., always starts with 1 */
+    num_hci_cmd_pkts = 1;
+
+    h5_alloc_data_retrans_timer();
+    h5_alloc_sync_retrans_timer();
+    h5_alloc_conf_retrans_timer();
+    h5_alloc_wait_controller_baudrate_ready_timer();
+    h5_alloc_hw_init_ready_timer();
+
+    rtk_h5.thread_data_retrans = -1;
+
+    rtk_h5.recv_data = RtbQueueInit();
+
+    if(create_data_ready_cb_thread() != 0)
+        LOG_ERROR(LOG_TAG, "H5 create_data_ready_cb_thread failed");
+
+    if(create_data_retransfer_thread() != 0)
+        LOG_ERROR(LOG_TAG, "H5 create_data_retransfer_thread failed");
+
+
+    rtk_h5.unack = RtbQueueInit();
+    rtk_h5.rel = RtbQueueInit();
+    rtk_h5.unrel = RtbQueueInit();
+
+    rtk_h5.rx_state = H5_W4_PKT_DELIMITER;
+    rtk_h5.rx_esc_state = H5_ESCSTATE_NOESC;
+
+    buffer_allocator = buffer_allocator_get_interface();
+
+    btsnoop = btsnoop_get_interface();
+#if H5_BTSNOOP_DUMP
+    h5_btsnoop_open();
+#endif
+#if RTK_BTSNOOP_NET_DUMP
+    rtk_btsnoop_net_open();
+#endif
+}
+
+/*******************************************************************************
+**
+** Function        hci_h5_cleanup
+**
+** Description     Clean H5 module
+**
+** Returns         None
+**
+*******************************************************************************/
+void hci_h5_cleanup(void)
+{
+    H5LogMsg("hci_h5_cleanup");
+    uint8_t try_cnt=10;
+    int result;
+
+    rtk_h5.cleanuping = 1;
+
+
+    //btsnoop_cleanup();
+
+    h5_free_data_retrans_timer();
+    h5_free_sync_retrans_timer();
+    h5_free_conf_retrans_timer();
+    h5_free_wait_controller_baudrate_ready_timer();
+    h5_free_hw_init_ready_timer();
+
+
+    if (h5_retransfer_running)
+    {
+        h5_retransfer_running = 0;
+        h5_retransfer_signal_event(H5_EVENT_EXIT);
+        if ((result = pthread_join(rtk_h5.thread_data_retrans, NULL)) < 0)
+        LOG_ERROR(LOG_TAG, "H5 pthread_join() FAILED result:%d", result);
+    }
+
+    ms_delay(200);
+
+    pthread_mutex_destroy(&rtk_h5.mutex);
+    pthread_cond_destroy(&rtk_h5.cond);
+
+    RtbQueueFree(rtk_h5.unack);
+    RtbQueueFree(rtk_h5.rel);
+    RtbQueueFree(rtk_h5.unrel);
+
+#if H5_BTSNOOP_DUMP
+    h5_btsnoop_close();
+#endif
+#if RTK_BTSNOOP_NET_DUMP
+    rtk_btsnoop_net_close();
+#endif
+    buffer_allocator = NULL;
+    btsnoop = NULL;
+    h5_int_hal_callbacks = NULL;
+    rtk_h5.internal_skb = NULL;
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_parse_msg
+**
+** Description     Construct HCI EVENT/ACL packets and send them to stack once
+**                 complete packet has been received.
+**
+** Returns         Number of need to be red bytes
+**
+*******************************************************************************/
+uint16_t  hci_h5_parse_msg(uint8_t *byte, uint16_t count)
+{
+    uint16_t bytes_needed = 0;
+    uint8_t     h5_byte;
+    h5_byte  = *byte;
+    //H5LogMsg("hci_h5_receive_msg byte:%d",h5_byte);
+    h5_recv(&rtk_h5, &h5_byte, count);
+    return 1;
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_receive_msg
+**
+** Description     Construct HCI EVENT/ACL packets and send them to stack once
+**                 complete packet has been received.
+**
+** Returns         Number of read bytes
+**
+*******************************************************************************/
+BOOLEAN  hci_h5_receive_msg(uint8_t *byte, uint16_t length)
+{
+    BOOLEAN status = FALSE;
+    //H5LogMsg("hci_h5_receive_msg byte:%d",h5_byte);
+    status = h5_recv(&rtk_h5, byte, length);
+    return status;
+}
+
+
+size_t  hci_h5_int_read_data(uint8_t * data_buffer, size_t max_size)
+{
+    H5LogMsg("hci_h5_int_read_data need_size = %d", max_size);
+    if(!rtk_h5.data_skb) {
+        LOG_ERROR(LOG_TAG, "hci_h5_int_read_data, there is no data to read for this packet!");
+        return -1;
+    }
+    sk_buff * skb_complete_pkt = rtk_h5.data_skb;
+    uint8_t *data = skb_get_data(skb_complete_pkt);
+    uint32_t data_len = skb_get_data_length(skb_complete_pkt);
+
+    H5LogMsg("hci_h5_int_read_data length = %d, need_size = %d", data_len, max_size);
+    if(data_len <= max_size) {
+        memcpy(data_buffer, data, data_len);
+        skb_free(&rtk_h5.data_skb);
+        rtk_h5.data_skb = NULL;
+        return data_len;
+    }
+    else {
+        memcpy(data_buffer, data, max_size);
+        skb_pull(rtk_h5.data_skb, max_size);
+        return max_size;
+    }
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_send_cmd
+**
+** Description     get cmd data from hal and send cmd
+**
+**
+** Returns          bytes send
+**
+*******************************************************************************/
+uint16_t hci_h5_send_cmd(serial_data_type_t type, uint8_t *data, uint16_t length)
+{
+    sk_buff * skb = NULL;
+    uint16_t bytes_to_send, opcode;
+
+    skb = skb_alloc_and_init(type, data, length);
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "send cmd skb_alloc_and_init fail!");
+        return -1;
+    }
+
+#if H5_BTSNOOP_DUMP
+    HC_BT_HDR *p_msg;
+    uint16_t len = BT_HC_HDR_SIZE + skb_get_data_length(skb);
+    p_msg = (HC_BT_HDR *) buffer_allocator->alloc(len);
+    /* Initialize buffer with received h5 data */
+    p_msg->offset = 0;
+    p_msg->layer_specific = 0;
+    p_msg->event = MSG_STACK_TO_HC_HCI_CMD;
+    p_msg->len = skb_get_data_length(skb);
+    memcpy((uint8_t *)(p_msg + 1), skb_get_data(skb), skb_get_data_length(skb));
+    h5_btsnoop_capture(p_msg, FALSE);
+    buffer_allocator->free(p_msg);
+#endif
+
+#if RTK_BTSNOOP_NET_DUMP
+    rtk_btsnoop_net_write(HCI_COMMAND_PKT, (uint8_t *)skb_get_data(skb), FALSE);
+#endif
+
+    h5_enqueue(skb);
+
+    num_hci_cmd_pkts--;
+
+    /* If this is an internal Cmd packet, the layer_specific field would
+         * have stored with the opcode of HCI command.
+         * Retrieve the opcode from the Cmd packet.
+         */
+    STREAM_TO_UINT16(opcode, data);
+    H5LogMsg("HCI Command opcode(0x%04X)", opcode);
+    if(opcode == 0x0c03)
+    {
+        H5LogMsg("RX HCI RESET Command, stop hw init timer");
+        h5_stop_hw_init_ready_timer();
+    }
+    bytes_to_send = h5_wake_up();
+    return length;
+}
+
+/*******************************************************************************
+**
+** Function        hci_h5_send_acl_data
+**
+** Description     get cmd data from hal and send cmd
+**
+**
+** Returns          bytes send
+**
+*******************************************************************************/
+uint16_t hci_h5_send_acl_data(serial_data_type_t type, uint8_t *data, uint16_t length)
+{
+    uint16_t bytes_to_send, lay_spec;
+    sk_buff * skb = NULL;
+
+    skb = skb_alloc_and_init(type, data, length);
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "hci_h5_send_acl_data, alloc skb buffer fail!");
+        return -1;
+    }
+
+#if H5_BTSNOOP_DUMP
+    HC_BT_HDR *p_msg;
+    uint16_t len = BT_HC_HDR_SIZE + skb_get_data_length(skb);
+    p_msg = (HC_BT_HDR *) buffer_allocator->alloc(len);
+    /* Initialize buffer with received h5 data */
+    p_msg->offset = 0;
+    p_msg->layer_specific = 0;
+    p_msg->event = MSG_STACK_TO_HC_HCI_ACL;
+    p_msg->len = skb_get_data_length(skb);
+    memcpy((uint8_t *)(p_msg + 1), skb_get_data(skb), skb_get_data_length(skb));
+    h5_btsnoop_capture(p_msg, FALSE);
+    buffer_allocator->free(p_msg);
+#endif
+
+#if RTK_BTSNOOP_NET_DUMP
+    rtk_btsnoop_net_write(HCI_ACLDATA_PKT, (uint8_t *)skb_get_data(skb),FALSE);
+#endif
+
+    h5_enqueue(skb);
+
+    bytes_to_send = h5_wake_up();
+    return length;
+}
+
+/*******************************************************************************
+**
+** Function        hci_h5_send_sco_data
+**
+** Description     get sco data from hal and send sco data
+**
+**
+** Returns          bytes send
+**
+*******************************************************************************/
+uint16_t hci_h5_send_sco_data(serial_data_type_t type, uint8_t *data, uint16_t length)
+{
+    sk_buff * skb = NULL;
+    uint16_t bytes_to_send, lay_spec;
+
+    skb = skb_alloc_and_init(type, data, length);
+    if(!skb) {
+        LOG_ERROR(LOG_TAG, "send sco data skb_alloc_and_init fail!");
+        return -1;
+    }
+
+#if H5_BTSNOOP_DUMP
+    HC_BT_HDR *p_msg;
+    uint16_t len = BT_HC_HDR_SIZE + skb_get_data_length(skb);
+    p_msg = (HC_BT_HDR *) buffer_allocator->alloc(len);
+    /* Initialize buffer with received h5 data */
+    p_msg->offset = 0;
+    p_msg->layer_specific = 0;
+    p_msg->event = MSG_STACK_TO_HC_HCI_SCO;
+    p_msg->len = skb_get_data_length(skb);
+    memcpy((uint8_t *)(p_msg + 1), skb_get_data(skb), skb_get_data_length(skb));
+    h5_btsnoop_capture(p_msg, FALSE);
+    buffer_allocator->free(p_msg);
+#endif
+
+#if RTK_BTSNOOP_NET_DUMP
+    rtk_btsnoop_net_write(HCI_SCODATA_PKT, (uint8_t *)skb_get_data(skb),FALSE);
+#endif
+
+    h5_enqueue(skb);
+
+    bytes_to_send = h5_wake_up();
+    return length;
+}
+
+
+/*******************************************************************************
+**
+** Function        hci_h5_send_int_cmd
+**
+** Description     Place the internal commands (issued internally by vendor lib)
+**                 in the tx_q.
+**
+** Returns         TRUE/FALSE
+**
+*******************************************************************************/
+uint8_t hci_h5_send_sync_cmd(uint16_t opcode, uint8_t *p_buf, uint16_t length)
+{
+    if(rtk_h5.link_estab_state == H5_UNINITIALIZED)
+    {
+        if(opcode == HCI_VSC_H5_INIT)
+        {
+            h5_start_hw_init_ready_timer();
+            hci_h5_send_sync_req();
+            h5_start_sync_retrans_timer();
+        }
+    }
+    else if(rtk_h5.link_estab_state == H5_ACTIVE)
+    {
+        H5LogMsg("hci_h5_send_sync_cmd(0x%x), link_estab_state = %d", opcode, rtk_h5.link_estab_state);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+uint8_t hci_h5_send_int_cmd(uint16_t opcode, HC_BT_HDR *p_buf, tINT_CMD_CBACK p_cback)
+{
+   // uint8_t * p =  (uint8_t *) (p_buf + 1);
+
+    if(rtk_h5.link_estab_state == H5_UNINITIALIZED)
+    {
+        if(opcode == HCI_VSC_H5_INIT)
+        {
+            h5_start_hw_init_ready_timer();
+            rtk_h5.cback_h5sync = p_cback;
+            hci_h5_send_sync_req();
+            h5_start_sync_retrans_timer();
+        }
+    }
+    else if(rtk_h5.link_estab_state == H5_ACTIVE)
+    {
+        if(opcode == 0xFC17)
+            rtk_h5.cback_h5sync = p_cback;
+
+        H5LogMsg("hci_h5_send_int_cmd(0x%x)", opcode);
+        if (rtk_h5.int_cmd_rsp_pending > INT_CMD_PKT_MAX_COUNT)
+        {
+            ALOGE( \
+            "Allow only %d outstanding internal commands at a time [Reject 0x%04X]"\
+            , INT_CMD_PKT_MAX_COUNT, opcode);
+            return FALSE;
+        }
+
+        rtk_h5.int_cmd_rsp_pending++;
+        rtk_h5.int_cmd[rtk_h5.int_cmd_wrt_idx].opcode = opcode;
+        rtk_h5.int_cmd[rtk_h5.int_cmd_wrt_idx].cback = p_cback;
+        rtk_h5.int_cmd_wrt_idx = ((rtk_h5.int_cmd_wrt_idx+1) & INT_CMD_PKT_IDX_MASK);
+
+        p_buf->layer_specific = opcode;
+
+        if(opcode == HCI_VSC_UPDATE_BAUDRATE
+            ||opcode == HCI_VSC_DOWNLOAD_FW_PATCH
+            ||opcode == HCI_VSC_READ_ROM_VERSION
+            ||opcode == HCI_VSC_READ_CHIP_TYPE
+            ||opcode == HCI_READ_LOCAL_VERSION_INFO
+            ||opcode == HCI_READ_BUFFER_SIZE
+            ||opcode == HCI_LE_READ_BUFFER_SIZE )
+        {
+            /* stamp signature to indicate an internal command */
+            if(p_buf != NULL)
+                btsnoop->capture((BT_HDR *)p_buf, FALSE);
+                uint8_t *p = ((uint8_t *)(p_buf + 1)) + p_buf->offset;
+                hci_h5_send_cmd(DATA_TYPE_COMMAND, p, p_buf->len);
+                //hci_h5_send_msg(p_buf);
+                buffer_allocator->free(p_buf);
+        }
+
+    }
+
+    return TRUE;
+}
+
+/***
+    Timer related functions
+*/
+static timer_t OsAllocateTimer(tTIMER_HANDLE_CBACK timer_callback)
+{
+    struct sigevent sigev;
+    timer_t timerid;
+
+    memset(&sigev, 0, sizeof(struct sigevent));
+    // Create the POSIX timer to generate signo
+    sigev.sigev_notify = SIGEV_THREAD;
+    //sigev.sigev_notify_thread_id = syscall(__NR_gettid);
+    sigev.sigev_notify_function = timer_callback;
+    sigev.sigev_value.sival_ptr = &timerid;
+
+    LOG_ERROR(LOG_TAG, "OsAllocateTimer rtk_parse sigev.sigev_notify_thread_id = syscall(__NR_gettid)!");
+    //Create the Timer using timer_create signal
+
+    if (timer_create(CLOCK_REALTIME, &sigev, &timerid) == 0)
+    {
+        return timerid;
+    }
+    else
+    {
+        LOG_ERROR(LOG_TAG, "timer_create error!");
+        return (timer_t)-1;
+    }
+}
+
+ int OsFreeTimer(timer_t timerid)
+{
+    int ret = 0;
+    ret = timer_delete(timerid);
+    if(ret != 0)
+        LOG_ERROR(LOG_TAG, "timer_delete fail with errno(%d)", errno);
+
+    return ret;
+}
+
+
+ static int OsStartTimer(timer_t timerid, int msec, int mode)
+ {
+    struct itimerspec itval;
+
+    itval.it_value.tv_sec = msec / 1000;
+    itval.it_value.tv_nsec = (long)(msec % 1000) * (1000000L);
+
+    if (mode == 1)
+
+    {
+        itval.it_interval.tv_sec    = itval.it_value.tv_sec;
+        itval.it_interval.tv_nsec = itval.it_value.tv_nsec;
+    }
+    else
+    {
+        itval.it_interval.tv_sec = 0;
+        itval.it_interval.tv_nsec = 0;
+    }
+
+    //Set the Timer when to expire through timer_settime
+
+    if (timer_settime(timerid, 0, &itval, NULL) != 0)
+    {
+        LOG_ERROR(LOG_TAG, "time_settime error!");
+        return -1;
+    }
+
+    return 0;
+
+}
+
+ static int OsStopTimer(timer_t timerid)
+ {
+    return OsStartTimer(timerid, 0, 0);
+ }
+
+static void h5_retransfer_timeout_handler(union sigval sigev_value) {
+    H5LogMsg("h5_retransfer_timeout_handler");
+    if(rtk_h5.cleanuping)
+    {
+        LOG_ERROR(LOG_TAG, "h5_retransfer_timeout_handler H5 is cleanuping, EXIT here!");
+        return;
+    }
+    h5_retransfer_signal_event(H5_EVENT_RX);
+}
+
+static void h5_sync_retrans_timeout_handler(union sigval sigev_value) {
+    H5LogMsg("h5_sync_retrans_timeout_handler");
+    if(rtk_h5.cleanuping)
+    {
+        LOG_ERROR(LOG_TAG, "h5_sync_retrans_timeout_handler H5 is cleanuping, EXIT here!");
+        return;
+    }
+    if(rtk_h5.sync_retrans_count < SYNC_RETRANS_COUNT)
+    {
+        hci_h5_send_sync_req();
+        rtk_h5.sync_retrans_count ++;
+    }
+    else
+    {
+        h5_stop_sync_retrans_timer();
+    }
+
+}
+
+static void h5_conf_retrans_timeout_handler(union sigval sigev_value) {
+    H5LogMsg("h5_conf_retrans_timeout_handler");
+    if(rtk_h5.cleanuping)
+    {
+        LOG_ERROR(LOG_TAG, "h5_conf_retrans_timeout_handler H5 is cleanuping, EXIT here!");
+        return;
+    }
+
+    H5LogMsg("Wait H5 Conf Resp timeout, %d times", rtk_h5.conf_retrans_count);
+    if(rtk_h5.conf_retrans_count < CONF_RETRANS_COUNT)
+    {
+        hci_h5_send_conf_req();
+        rtk_h5.conf_retrans_count++;
+    }
+    else
+    {
+        h5_stop_conf_retrans_timer();
+    }
+
+}
+
+static void h5_wait_controller_baudrate_ready_timeout_handler(union sigval sigev_value) {
+    H5LogMsg("h5_wait_ct_baundrate_ready_timeout_handler");
+    if(rtk_h5.cleanuping)
+    {
+        LOG_ERROR(LOG_TAG, "h5_wait_controller_baudrate_ready_timeout_handler H5 is cleanuping, EXIT here!");
+        if(rtk_h5.internal_skb)
+            skb_free(&rtk_h5.internal_skb);
+        return;
+    }
+    H5LogMsg("No Controller retransfer, baudrate of controller ready");
+    pthread_mutex_lock(&rtk_h5.data_mutex);
+    skb_queue_tail(rtk_h5.recv_data, rtk_h5.internal_skb);
+    pthread_cond_signal(&rtk_h5.data_cond);
+    pthread_mutex_unlock(&rtk_h5.data_mutex);
+
+    rtk_h5.internal_skb = NULL;
+}
+
+static void h5_hw_init_ready_timeout_handler(union sigval sigev_value) {
+    H5LogMsg("h5_hw_init_ready_timeout_handler");
+    if(rtk_h5.cleanuping)
+    {
+        LOG_ERROR(LOG_TAG, "H5 is cleanuping, EXIT here!");
+        return;
+    }
+    H5LogMsg("TIMER_H5_HW_INIT_READY timeout, kill restart BT");
+    kill(getpid(), SIGKILL);
+}
+
+/*
+** h5 data retrans timer functions
+*/
+int h5_alloc_data_retrans_timer()
+ {
+    // Create and set the timer when to expire
+    rtk_h5.timer_data_retrans = OsAllocateTimer(h5_retransfer_timeout_handler);
+
+    return 0;
+ }
+
+int h5_free_data_retrans_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_data_retrans);
+}
+
+
+int h5_start_data_retrans_timer()
+{
+    return OsStartTimer(rtk_h5.timer_data_retrans, DATA_RETRANS_TIMEOUT_VALUE, 0);
+}
+
+int h5_stop_data_retrans_timer()
+{
+    return OsStopTimer(rtk_h5.timer_data_retrans);
+}
+
+
+
+/*
+** h5 sync retrans timer functions
+*/
+int h5_alloc_sync_retrans_timer()
+ {
+    // Create and set the timer when to expire
+    rtk_h5.timer_sync_retrans = OsAllocateTimer(h5_sync_retrans_timeout_handler);
+
+    return 0;
+
+ }
+
+int h5_free_sync_retrans_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_sync_retrans);
+}
+
+
+int h5_start_sync_retrans_timer()
+{
+    return OsStartTimer(rtk_h5.timer_sync_retrans, SYNC_RETRANS_TIMEOUT_VALUE, 1);
+}
+
+int h5_stop_sync_retrans_timer()
+{
+    return OsStopTimer(rtk_h5.timer_sync_retrans);
+}
+
+
+/*
+** h5 config retrans timer functions
+*/
+int h5_alloc_conf_retrans_timer()
+ {
+    // Create and set the timer when to expire
+    rtk_h5.timer_conf_retrans = OsAllocateTimer(h5_conf_retrans_timeout_handler);
+
+    return 0;
+
+ }
+
+int h5_free_conf_retrans_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_conf_retrans);
+}
+
+
+int h5_start_conf_retrans_timer()
+{
+    return OsStartTimer(rtk_h5.timer_conf_retrans, CONF_RETRANS_TIMEOUT_VALUE, 1);
+}
+
+int h5_stop_conf_retrans_timer()
+{
+    return OsStopTimer(rtk_h5.timer_conf_retrans);
+}
+
+
+/*
+** h5 wait controller baudrate ready timer functions
+*/
+int h5_alloc_wait_controller_baudrate_ready_timer()
+ {
+    // Create and set the timer when to expire
+    rtk_h5.timer_wait_ct_baudrate_ready = OsAllocateTimer(h5_wait_controller_baudrate_ready_timeout_handler);
+
+    return 0;
+ }
+
+int h5_free_wait_controller_baudrate_ready_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_wait_ct_baudrate_ready);
+}
+
+
+int h5_start_wait_controller_baudrate_ready_timer()
+{
+    return OsStartTimer(rtk_h5.timer_wait_ct_baudrate_ready, WAIT_CT_BAUDRATE_READY_TIMEOUT_VALUE, 0);
+}
+
+int h5_stop_wait_controller_baudrate_ready_timer()
+{
+    return OsStopTimer(rtk_h5.timer_wait_ct_baudrate_ready);
+}
+
+
+/*
+** h5 hw init ready timer functions
+*/
+int h5_alloc_hw_init_ready_timer()
+ {
+    // Create and set the timer when to expire
+    rtk_h5.timer_h5_hw_init_ready = OsAllocateTimer(h5_hw_init_ready_timeout_handler);
+
+    return 0;
+
+ }
+
+int h5_free_hw_init_ready_timer()
+{
+    return OsFreeTimer(rtk_h5.timer_h5_hw_init_ready);
+}
+
+
+int h5_start_hw_init_ready_timer()
+{
+    return OsStartTimer(rtk_h5.timer_h5_hw_init_ready, H5_HW_INIT_READY_TIMEOUT_VALUE, 0);
+}
+
+int h5_stop_hw_init_ready_timer()
+{
+    return OsStopTimer(rtk_h5.timer_h5_hw_init_ready);
+}
+
+
+/******************************************************************************
+**  HCI H5 Services interface table
+******************************************************************************/
+
+const tHCI_H5_IF hci_h5_func_table =
+{
+    .send_int_cmd = hci_h5_send_int_cmd,
+};
+
+const hci_h5_t hci_h5_int_func_table =
+{
+    .h5_int_init        = hci_h5_int_init,
+    .h5_int_cleanup     = hci_h5_cleanup,
+    .h5_send_cmd        = hci_h5_send_cmd,
+    .h5_send_sync_cmd   = hci_h5_send_sync_cmd,
+    .h5_send_acl_data   = hci_h5_send_acl_data,
+    .h5_send_sco_data   = hci_h5_send_sco_data,
+    .h5_recv_msg        = hci_h5_receive_msg,
+    .h5_int_read_data   = hci_h5_int_read_data,
+};
+
+const hci_h5_t *hci_get_h5_int_interface() {
+  return &hci_h5_int_func_table;
+}
+
+const tHCI_H5_IF *hci_get_h5_interface() {
+  return &hci_h5_func_table;
+}
+
+
diff --git a/hci/src/hci_h5_int.h b/hci/src/hci_h5_int.h
new file mode 100755
index 0000000..a074e43
--- /dev/null
+++ b/hci/src/hci_h5_int.h
@@ -0,0 +1,66 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "osi/include/thread.h"
+#include "osi/include/log.h"
+#include "vendor.h"
+#include "hci_hal.h"
+#include "hcidefs.h"
+
+//HCI Command opcodes
+#define HCI_LE_READ_BUFFER_SIZE     0x2002
+#define DATA_TYPE_H5                0x05
+
+//HCI VENDOR Command opcode
+#define HCI_VSC_H5_INIT                 0xFCEE
+#define HCI_VSC_UPDATE_BAUDRATE         0xFC17
+#define HCI_VSC_DOWNLOAD_FW_PATCH       0xFC20
+#define HCI_VSC_READ_ROM_VERSION        0xFC6D
+#define HCI_VSC_READ_CHIP_TYPE          0xFC61
+#define HCI_VSC_SET_WAKE_UP_DEVICE      0xFC7B
+#define HCI_VSC_BT_OFF                  0xFC28
+
+
+typedef struct hci_h5_hal_callbacks_t{
+    uint16_t    (*h5_int_transmit_data_cb)(serial_data_type_t type, uint8_t *data, uint16_t length);
+    void        (*h5_data_ready_cb)(serial_data_type_t type);
+} hci_h5_hal_callbacks_t;
+
+typedef struct hci_h5_t {
+     void     (*h5_int_init)(hci_h5_hal_callbacks_t *h5_callbacks);
+     void     (*h5_int_cleanup)(void);
+     uint16_t (*h5_send_cmd)(serial_data_type_t type, uint8_t *data, uint16_t length);
+     uint8_t  (*h5_send_sync_cmd)(uint16_t opcode, uint8_t *data, uint16_t length);
+     uint16_t (*h5_send_acl_data)(serial_data_type_t type, uint8_t *data, uint16_t length);
+     uint16_t (*h5_send_sco_data)(serial_data_type_t type, uint8_t *data, uint16_t length);
+     BOOLEAN  (*h5_recv_msg)(uint8_t *byte, uint16_t length);
+     size_t   (*h5_int_read_data)(uint8_t *data_buffer, size_t max_size);
+} hci_h5_t;
+
+typedef struct {
+    uint8_t (*send_int_cmd)(uint16_t opcode, HC_BT_HDR *p_buf, tINT_CMD_CBACK p_cback);
+} tHCI_H5_IF;
+
+const hci_h5_t *hci_get_h5_int_interface(void);
+
+
diff --git a/hci/src/hci_hal.c b/hci/src/hci_hal.c
old mode 100644
new mode 100755
index fa526ce..5b935a3
--- a/hci/src/hci_hal.c
+++ b/hci/src/hci_hal.c
@@ -17,12 +17,22 @@
  ******************************************************************************/
 
 #include "hci_hal.h"
-
+#ifdef BLUETOOTH_RTK
+extern bool bluetooth_rtk_h5_flag;
+#endif
 const hci_hal_t *hci_hal_get_interface() {
 #if HCI_USE_MCT
   return hci_hal_mct_get_interface();
 #else
+#ifdef BLUETOOTH_RTK
+  if(bluetooth_rtk_h5_flag) {
+    return hci_hal_h5_get_interface();
+  }
+  else
+    return hci_hal_h4_get_interface();
+#else
   return hci_hal_h4_get_interface();
 #endif
+#endif
 }
 
diff --git a/hci/src/hci_hal_h5.c b/hci/src/hci_hal_h5.c
new file mode 100755
index 0000000..4057d73
--- /dev/null
+++ b/hci/src/hci_hal_h5.c
@@ -0,0 +1,312 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2014 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "bt_hci_h5"
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#include "osi/include/eager_reader.h"
+#include "hci_hal.h"
+#include "osi/include/osi.h"
+#include "osi/include/log.h"
+#include "osi/include/reactor.h"
+#include "osi/include/thread.h"
+#include "vendor.h"
+
+#include "hci_layer.h"
+#include "hci_h5_int.h"
+
+#define HCI_HAL_SERIAL_BUFFER_SIZE 1026
+#define HCI_BLE_EVENT 0x3e
+
+// Increased HCI thread priority to keep up with the audio sub-system
+// when streaming time sensitive data (A2DP).
+#define HCI_THREAD_PRIORITY -19
+
+// Our interface and modules we import
+static const hci_hal_t h5_interface;
+static const hci_h5_t* h5_int_interface;
+static const hci_hal_callbacks_t *h5_hal_callbacks;
+static const vendor_t *h5_vendor;
+
+static thread_t *thread; // Not owned by us
+
+static int uart_fd;
+static eager_reader_t *uart_stream;
+static serial_data_type_t current_data_type;
+static bool stream_has_interpretation;
+static bool stream_corruption_detected;
+static uint8_t stream_corruption_bytes_to_ignore;
+
+static void h5_data_ready_cb(serial_data_type_t type);
+static uint16_t h5_int_transmit_data_cb(serial_data_type_t type, uint8_t *data, uint16_t length) ;
+static void h5_event_uart_has_bytes(eager_reader_t *reader, void *context);
+
+static  hci_h5_hal_callbacks_t h5_int_hal_callbacks = {
+    .h5_int_transmit_data_cb = h5_int_transmit_data_cb,
+    .h5_data_ready_cb = h5_data_ready_cb,
+};
+
+
+// Interface functions
+
+static bool h5_hal_init(const hci_hal_callbacks_t *upper_callbacks, thread_t *upper_thread) {
+  assert(upper_callbacks != NULL);
+  assert(upper_thread != NULL);
+
+  h5_hal_callbacks = upper_callbacks;
+  thread = upper_thread;
+  h5_int_interface = hci_get_h5_int_interface();
+  h5_int_interface->h5_int_init(&h5_int_hal_callbacks);
+  return true;
+}
+
+static bool h5_hal_open() {
+  LOG_INFO(LOG_TAG, "%s", __func__);
+  // TODO(zachoverflow): close if already open / or don't reopen (maybe at the hci layer level)
+
+  int fd_array[CH_MAX];
+  int number_of_ports = h5_vendor->send_command(VENDOR_OPEN_USERIAL, &fd_array);
+
+  if (number_of_ports != 1) {
+    LOG_ERROR(LOG_TAG, "%s opened the wrong number of ports: got %d, expected 1.", __func__, number_of_ports);
+    goto error;
+  }
+
+  uart_fd = fd_array[0];
+  if (uart_fd == INVALID_FD) {
+    LOG_ERROR(LOG_TAG, "%s unable to open the uart serial port.", __func__);
+    goto error;
+  }
+
+  uart_stream = eager_reader_new(uart_fd, &allocator_malloc, HCI_HAL_SERIAL_BUFFER_SIZE, SIZE_MAX, "hci_single_channel");
+  if (!uart_stream) {
+    LOG_ERROR(LOG_TAG, "%s unable to create eager reader for the uart serial port.", __func__);
+    goto error;
+  }
+
+  stream_has_interpretation = false;
+  stream_corruption_detected = false;
+  stream_corruption_bytes_to_ignore = 0;
+  eager_reader_register(uart_stream, thread_get_reactor(thread), h5_event_uart_has_bytes, NULL);
+
+  // Raise thread priorities to keep up with audio
+  thread_set_priority(thread, HCI_THREAD_PRIORITY);
+  thread_set_priority(eager_reader_get_read_thread(uart_stream), HCI_THREAD_PRIORITY);
+
+  return true;
+
+error:
+  h5_interface.close();
+  return false;
+}
+
+static void h5_hal_close() {
+  LOG_INFO(LOG_TAG, "%s", __func__);
+
+  eager_reader_free(uart_stream);
+  h5_vendor->send_command(VENDOR_CLOSE_USERIAL, NULL);
+  uart_fd = INVALID_FD;
+  h5_int_interface->h5_int_cleanup();
+}
+
+static size_t h5_read_data(serial_data_type_t type, uint8_t *buffer, size_t max_size)
+{
+  int size = 0;
+  if (type < DATA_TYPE_ACL || type > DATA_TYPE_EVENT) {
+    LOG_ERROR(LOG_TAG, "%s invalid data type: %d", __func__, type);
+    return 0;
+  } else if (!stream_has_interpretation) {
+    LOG_ERROR(LOG_TAG, "%s with no valid stream intepretation.", __func__);
+    return 0;
+  } else if (current_data_type != type) {
+    LOG_ERROR(LOG_TAG, "%s with different type than existing interpretation.", __func__);
+    return 0;
+  }
+
+  if(max_size == 0) {
+    return 0;
+  }
+  size = h5_int_interface->h5_int_read_data(buffer, max_size);
+  if(size == -1) {
+    LOG_ERROR(LOG_TAG, "Error there is no data to be read, stack error or fw error!");
+    return 0;
+  }
+  return size;
+}
+
+static void h5_packet_finished(serial_data_type_t type) {
+  if (!stream_has_interpretation)
+    LOG_ERROR(LOG_TAG, "%s with no existing stream interpretation.", __func__);
+  else if (current_data_type != type)
+    LOG_ERROR(LOG_TAG, "%s with different type than existing interpretation.", __func__);
+
+  stream_has_interpretation = false;
+}
+
+uint16_t h5_int_transmit_data_cb(serial_data_type_t type, uint8_t *data, uint16_t length) {
+      assert(data != NULL);
+      assert(length > 0);
+
+      LOG_DEBUG(LOG_TAG, "hci_hal_h5 %s data type: %d", __func__, type);
+
+      if (type != DATA_TYPE_H5) {
+        LOG_ERROR(LOG_TAG, "%s invalid data type: %d", __func__, type);
+        return 0;
+      }
+
+      uint16_t transmitted_length = 0;
+      while (length > 0) {
+        ssize_t ret = write(uart_fd, data + transmitted_length, length);
+        switch (ret) {
+          case -1:
+            LOG_ERROR(LOG_TAG, "In %s, error writing to the uart serial port: %s", __func__, strerror(errno));
+            goto done;
+          case 0:
+            // If we wrote nothing, don't loop more because we
+            // can't go to infinity or beyond
+            goto done;
+          default:
+            transmitted_length += ret;
+            length -= ret;
+            break;
+        }
+      }
+
+done:;
+
+      return transmitted_length;
+
+}
+
+static void h5_data_ready_cb(serial_data_type_t type)
+{
+    stream_has_interpretation = true;
+    current_data_type = type;
+    h5_hal_callbacks->data_ready(current_data_type);
+}
+
+static uint16_t h5_transmit_data(serial_data_type_t type, uint8_t *data, uint16_t length) {
+    assert(data != NULL);
+    assert(length > 0);
+
+    uint16_t transmitted_length = 0;
+    uint16_t opcode;
+    uint8_t  *data_temp = data;
+    LOG_DEBUG(LOG_TAG, "hci_hal_h5 %s, data type: %d", __func__, type);
+
+    if (type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO) {
+        LOG_ERROR(LOG_TAG, "%s invalid data type: %d", __func__, type);
+        return 0;
+    }
+
+    switch (type) {
+    case DATA_TYPE_COMMAND:
+        STREAM_TO_UINT16(opcode, data_temp);
+        LOG_DEBUG(LOG_TAG, "cmd opcode  = 0x%0x", opcode);
+        if(opcode == HCI_VSC_H5_INIT)
+        {
+            transmitted_length = length;
+            h5_int_interface->h5_send_sync_cmd(opcode, NULL, length);
+            break;
+        }
+        transmitted_length = h5_int_interface->h5_send_cmd(type, data, length);
+    break;
+
+    case DATA_TYPE_ACL:
+        transmitted_length = h5_int_interface->h5_send_acl_data(type, data, length);
+    break;
+
+    case DATA_TYPE_SCO:
+        transmitted_length = h5_int_interface->h5_send_sco_data(type, data, length);
+    break;
+
+    default:
+    break;
+    }
+    return transmitted_length;
+}
+
+// Internal functions
+
+// WORKAROUND:
+// As exhibited by b/23934838, during result-heavy LE scans, the UART byte
+// stream can get corrupted, leading to assertions caused by mis-interpreting
+// the bytes following the corruption.
+// This workaround looks for tell-tale signs of a BLE event and attempts to
+// skip the correct amount of bytes in the stream to re-synchronize onto
+// a packet boundary.
+// Function returns true if |byte_read| has been processed by the workaround.
+static bool stream_corrupted_during_le_scan_workaround(const uint8_t byte_read)
+{
+  if (!stream_corruption_detected && byte_read == HCI_BLE_EVENT) {
+    LOG_ERROR(LOG_TAG, "%s HCI stream corrupted (message type 0x3E)!", __func__);
+    stream_corruption_detected = true;
+    return true;
+  }
+
+  if (stream_corruption_detected) {
+    if (stream_corruption_bytes_to_ignore == 0) {
+      stream_corruption_bytes_to_ignore = byte_read;
+      LOG_ERROR(LOG_TAG, "%s About to skip %d bytes...", __func__, stream_corruption_bytes_to_ignore);
+    } else {
+      --stream_corruption_bytes_to_ignore;
+    }
+
+    if (stream_corruption_bytes_to_ignore == 0) {
+      LOG_ERROR(LOG_TAG, "%s Back to our regularly scheduled program...", __func__);
+      stream_corruption_detected = false;
+    }
+    return true;
+  }
+
+  return false;
+}
+
+// See what data is waiting, and notify the upper layer
+static void h5_event_uart_has_bytes(eager_reader_t *reader, UNUSED_ATTR void *context) {
+    uint8_t data_buffer[10] = {0};
+    size_t read_len = 0;
+    BOOLEAN status = FALSE;
+    read_len = eager_reader_read(reader, data_buffer, 10);
+    if(read_len > 0)
+        status = h5_int_interface->h5_recv_msg(data_buffer, read_len);
+}
+
+static const hci_hal_t h5_interface = {
+  h5_hal_init,
+
+  h5_hal_open,
+  h5_hal_close,
+
+  h5_read_data,
+  h5_packet_finished,
+  h5_transmit_data,
+};
+
+const hci_hal_t *hci_hal_h5_get_interface() {
+  h5_vendor = vendor_get_interface();
+  return &h5_interface;
+}
+
+const hci_hal_t *hci_hal_h5_get_test_interface(vendor_t *vendor_interface) {
+  h5_vendor = vendor_interface;
+  return &h5_interface;
+}
diff --git a/hci/src/hci_layer.c b/hci/src/hci_layer.c
old mode 100644
new mode 100755
index d566141..1cfb5b3
--- a/hci/src/hci_layer.c
+++ b/hci/src/hci_layer.c
@@ -43,6 +43,9 @@
 #include "osi/include/reactor.h"
 #include "packet_fragmenter.h"
 #include "vendor.h"
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 
 // TODO(zachoverflow): remove this hack extern
 #include <hardware/bluetooth.h>
@@ -110,12 +113,19 @@ static hci_t interface;
 static const allocator_t *buffer_allocator;
 static const btsnoop_t *btsnoop;
 static const hci_hal_t *hal;
+#ifdef BLUETOOTH_RTK
+char bt_hci_device_node[BT_HCI_DEVICE_NODE_MAX_LEN] = {0};
+bool bluetooth_rtk_h5_flag = FALSE;
+#endif
 static const hci_hal_callbacks_t hal_callbacks;
 static const hci_inject_t *hci_inject;
 static const low_power_manager_t *low_power_manager;
 static const packet_fragmenter_t *packet_fragmenter;
 static const packet_fragmenter_callbacks_t packet_fragmenter_callbacks;
 static const vendor_t *vendor;
+#ifdef BLUETOOTH_RTK_COEX
+static const rtk_parse_manager_t *rtk_parse_manager;
+#endif
 
 static future_t *startup_future;
 static thread_t *thread; // We own this
@@ -244,6 +254,9 @@ static future_t *start_up(void) {
   vendor->open(btif_local_bd_addr.address, &interface);
   hal->init(&hal_callbacks, thread);
   low_power_manager->init(thread);
+#ifdef BLUETOOTH_RTK_COEX
+  rtk_parse_manager->rtk_parse_init(&interface);
+#endif
 
   vendor->set_callback(VENDOR_CONFIGURE_FIRMWARE, firmware_config_callback);
   vendor->set_callback(VENDOR_CONFIGURE_SCO, sco_config_callback);
@@ -294,6 +307,10 @@ static future_t *shut_down() {
     thread_join(thread);
   }
 
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_manager->rtk_parse_cleanup();
+#endif
+
   fixed_queue_free(command_queue, osi_free);
   command_queue = NULL;
   fixed_queue_free(packet_queue, buffer_allocator->free);
@@ -503,6 +520,14 @@ static void event_packet_ready(fixed_queue_t *queue, UNUSED_ATTR void *context)
 static void transmit_fragment(BT_HDR *packet, bool send_transmit_finished) {
   uint16_t event = packet->event & MSG_EVT_MASK;
   serial_data_type_t type = event_to_data_type(event);
+#ifdef BLUETOOTH_RTK_COEX
+  uint8_t *pp = ((uint8_t *)(packet + 1)) + packet->offset;
+  if (event == MSG_STACK_TO_HC_HCI_ACL)
+    rtk_parse_manager->rtk_parse_l2cap_data(pp,1);
+  if (event == MSG_STACK_TO_HC_HCI_CMD)
+    rtk_parse_manager->rtk_parse_command(pp);
+#endif
+
 
   btsnoop->capture(packet, false);
   hal->transmit_data(type, packet->data + packet->offset, packet->len);
@@ -659,8 +684,15 @@ static bool filter_incoming_event(BT_HDR *packet) {
   STREAM_TO_UINT8(event_code, stream);
   STREAM_SKIP_UINT8(stream); // Skip the parameter total length field
 
+#ifdef BLUETOOTH_RTK_COEX
+    rtk_parse_manager->rtk_parse_internal_event_intercept(packet->data);
+#endif
   if (event_code == HCI_COMMAND_COMPLETE_EVT) {
     STREAM_TO_UINT8(command_credits, stream);
+#ifdef BLUETOOTH_RTK
+    if(command_credits > 0)
+        command_credits = 1;
+#endif
     STREAM_TO_UINT16(opcode, stream);
 
     wait_entry = get_waiting_command(opcode);
@@ -681,6 +713,10 @@ static bool filter_incoming_event(BT_HDR *packet) {
     uint8_t status;
     STREAM_TO_UINT8(status, stream);
     STREAM_TO_UINT8(command_credits, stream);
+#ifdef BLUETOOTH_RTK
+    if(command_credits > 0)
+        command_credits = 1;
+#endif
     STREAM_TO_UINT16(opcode, stream);
 
     // If a command generates a command status event, it won't be getting a command complete event
@@ -721,6 +757,12 @@ static void dispatch_reassembled(BT_HDR *packet) {
   // Events should already have been dispatched before this point
   assert((packet->event & MSG_EVT_MASK) != MSG_HC_TO_STACK_HCI_EVT);
   assert(upwards_data_queue != NULL);
+#ifdef BLUETOOTH_RTK_COEX
+    if ((packet->event& MSG_EVT_MASK) == MSG_HC_TO_STACK_HCI_ACL) {
+      uint8_t *pp = ((uint8_t *)(packet + 1)) + packet->offset;
+      rtk_parse_manager->rtk_parse_l2cap_data(pp,0);
+    }
+#endif
 
   if (upwards_data_queue) {
     fixed_queue_enqueue(upwards_data_queue, packet);
@@ -832,6 +874,9 @@ const hci_t *hci_layer_get_interface() {
   vendor = vendor_get_interface();
   low_power_manager = low_power_manager_get_interface();
 
+#ifdef BLUETOOTH_RTK_COEX
+  rtk_parse_manager = rtk_parse_manager_get_interface();
+#endif
   init_layer_interface();
   return &interface;
 }
diff --git a/hci/src/rtk_btsnoop_net.c b/hci/src/rtk_btsnoop_net.c
new file mode 100755
index 0000000..4124a9f
--- /dev/null
+++ b/hci/src/rtk_btsnoop_net.c
@@ -0,0 +1,237 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2013 Google, Inc.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "rtk_btsnoop_net"
+
+#include <assert.h>
+#include <errno.h>
+#include <netinet/in.h>
+#include <pthread.h>
+#include <stdbool.h>
+#include <string.h>
+#include <sys/prctl.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <time.h>
+
+#include "osi/include/osi.h"
+#include "osi/include/log.h"
+#include "hci_hal.h"
+
+#define DATA_DIRECT_2_ELLISY 1
+
+#define HCI_COMMAND         0x01
+#define HCI_ACL_DATA_H2C    0x02
+#define HCI_ACL_DATA_C2H    0x82
+#define HCI_SCO_DATA_H2C    0x03
+#define HCI_SCO_DATA_C2H    0x83
+#define HCI_EVENT           0x84
+
+#define HCI_COMMAND_PKT         0x01
+#define HCI_ACLDATA_PKT         0x02
+#define HCI_SCODATA_PKT         0x03
+#define HCI_EVENT_PKT           0x04
+
+
+static void rtk_safe_close_(int *fd);
+static void *rtk_listen_fn_(void *context);
+
+static const char *RTK_LISTEN_THREAD_NAME_ = "rtk_btsnoop_net";
+static const int RTK_LOCALHOST_ = 0xC0A80AE2;       // 192.168.10.226
+static const int RTK_LISTEN_PORT_ = 8872;
+
+static const int RTK_REMOTEHOST_ = 0xC0A80A03;       // 192.168.10.21
+static const int RTK_REMOTE_PORT_ = 24352;
+
+
+static pthread_t rtk_listen_thread_;
+static bool rtk_listen_thread_valid_ = false;
+static pthread_mutex_t rtk_client_socket_lock_ = PTHREAD_MUTEX_INITIALIZER;
+static int rtk_listen_socket_ = -1;
+
+void rtk_btsnoop_net_open() {
+    rtk_listen_thread_valid_ = (pthread_create(&rtk_listen_thread_, NULL, rtk_listen_fn_, NULL) == 0);
+    if (!rtk_listen_thread_valid_) {
+        LOG_ERROR(LOG_TAG, "%s pthread_create failed: %s", __func__, strerror(errno));
+    } else {
+        LOG_DEBUG(LOG_TAG, "initialized");
+    }
+}
+
+void rtk_btsnoop_net_close() {
+    if (rtk_listen_thread_valid_) {
+        shutdown(rtk_listen_socket_, SHUT_RDWR);
+        pthread_join(rtk_listen_thread_, NULL);
+        rtk_listen_thread_valid_ = false;
+    }
+}
+
+void rtk_btsnoop_net_write(serial_data_type_t type, uint8_t *data, bool is_received) {
+    if (rtk_listen_socket_ == -1) {
+        return;
+    }
+    int length = 0;
+    uint8_t *p = data;
+
+    switch (type) {
+    case HCI_COMMAND_PKT:
+            length = data[2] + 3;
+    break;
+    case HCI_ACLDATA_PKT:
+        length = (data[3] << 8) + data[2] + 4;
+    break;
+    case HCI_SCODATA_PKT:
+        length = data[2] + 3;
+    break;
+    case HCI_EVENT_PKT:
+        length = data[1] + 2;
+    break;
+    default:
+        break;
+    }
+
+
+    uint8_t buffer[4126] = {0};
+    //uint8_t test_buffer[] = {0x03, 0x00, 0x00, 0x00, 0x01, 0x01, 0x10, 0x00};
+    //uint8_t test_buffer2[] = {0x01, 0x10, 0x00};
+    struct sockaddr_in client_addr;
+    int i = 0;
+
+#if DATA_DIRECT_2_ELLISY
+    uint8_t bit_rate[4] = {0x00, 0x1b, 0x37, 0x4b};
+    struct tm *t;
+    time_t tt;
+    time(&tt);
+    t = localtime(&tt);
+
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+
+    uint64_t nano_time = (t->tm_hour * 3600 + t->tm_min * 60 + t->tm_sec) * 1000 * 1000LL * 1000 + tv.tv_usec * 1000;
+    uint16_t year = (t->tm_year + 1900) & 0xFFFF;
+    uint8_t  month = (t->tm_mon+1) & 0xFF;
+    uint8_t  day =
+    buffer[0] = 0x02;
+    buffer[1] = 0x00;
+    buffer[2] = 0x01;
+    buffer[3] = 0x02;
+    //time
+    memcpy(&buffer[4], &year, 2);
+    buffer[6] = month;
+    buffer[7] = day;
+    memcpy(&buffer[8], &nano_time, 6);
+    //bit rate
+    buffer[14] = 0x80;
+    memcpy(&buffer[15], bit_rate, 4);
+    //type
+    buffer[19] = 0x81;
+    i = 20;
+#else
+    memcpy(&buffer[i], &length, sizeof(int));
+    i = 4;
+#endif
+    switch (type) {
+        case HCI_COMMAND_PKT:
+        buffer[i] = HCI_COMMAND;
+        break;
+
+        case HCI_ACLDATA_PKT:
+        if(is_received) {
+            buffer[i] = HCI_ACL_DATA_C2H;
+        }
+        else {
+            buffer[i] = HCI_ACL_DATA_H2C;
+        }
+        break;
+
+        case HCI_SCODATA_PKT:
+        if(is_received) {
+            buffer[i] = HCI_SCO_DATA_C2H;
+        }
+        else {
+            buffer[i] = HCI_SCO_DATA_H2C;
+        }
+        break;
+
+        case HCI_EVENT_PKT:
+        buffer[i] = HCI_EVENT;
+        break;
+
+        default:
+        buffer[i] = 0;
+        break;
+
+    }
+#if DATA_DIRECT_2_ELLISY
+    //buffer[i] = HCI_COMMAND;
+    buffer[21] = 0x82;
+    i = 22;
+#else
+    i = 5;
+#endif
+    memcpy(&buffer[i], data, length);
+    //memcpy(&buffer[i], test_buffer2, 3);
+    memset(&client_addr, 0, sizeof(client_addr));
+    client_addr.sin_family = AF_INET;
+    client_addr.sin_addr.s_addr = htonl(RTK_REMOTEHOST_);
+    client_addr.sin_port = htons(RTK_REMOTE_PORT_);
+    pthread_mutex_lock(&rtk_client_socket_lock_);
+    sendto(rtk_listen_socket_, buffer, (length+i), 0,(struct sockaddr*)&client_addr, sizeof(struct sockaddr_in));
+    //sendto(rtk_listen_socket_, buffer, 25, 0,(struct sockaddr*)&client_addr, sizeof(struct sockaddr_in));
+    pthread_mutex_unlock(&rtk_client_socket_lock_);
+}
+
+static void *rtk_listen_fn_(UNUSED_ATTR void *context) {
+    prctl(PR_SET_NAME, (unsigned long)RTK_LISTEN_THREAD_NAME_, 0, 0, 0);
+
+    rtk_listen_socket_ = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
+    if (rtk_listen_socket_ == -1) {
+        LOG_ERROR(LOG_TAG, "%s socket creation failed: %s", __func__, strerror(errno));
+        goto cleanup;
+    }
+
+    struct sockaddr_in addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = htonl(RTK_LOCALHOST_);
+    addr.sin_port = htons(RTK_LISTEN_PORT_);
+
+    struct sockaddr_in client_addr;
+    memset(&client_addr, 0, sizeof(client_addr));
+    client_addr.sin_family = AF_INET;
+    client_addr.sin_addr.s_addr = htonl(RTK_REMOTEHOST_);
+    client_addr.sin_port = htons(RTK_REMOTE_PORT_);
+
+    if (bind(rtk_listen_socket_, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
+        LOG_ERROR(LOG_TAG, "%s unable to bind listen socket: %s", __func__, strerror(errno));
+        goto cleanup;
+    }
+
+    return NULL;
+cleanup:
+    rtk_safe_close_(&rtk_listen_socket_);
+    return NULL;
+}
+
+static void rtk_safe_close_(int *fd) {
+  assert(fd != NULL);
+  if (*fd != -1) {
+    close(*fd);
+    *fd = -1;
+  }
+}
diff --git a/hci/src/rtk_parse.c b/hci/src/rtk_parse.c
new file mode 100755
index 0000000..da4fdc6
--- /dev/null
+++ b/hci/src/rtk_parse.c
@@ -0,0 +1,2670 @@
+/******************************************************************************
+ *
+ *  Copyright (C) 2016 Realtek Corporation.
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+/******************************************************************************
+*
+*	Module Name:
+*		rtk_parse.c
+*
+*	Abstract:
+*		Contains wifi-bt coex functions implemented by bluedroid stack
+*
+*	Major Change History:
+*	      When             Who       What
+*	 	---------------------------------------------------------------
+*	    2015-12-15      lamparten   modified
+*	    2014-10-23       kyle_xu    modified
+*	Notes:
+*		  This is designed for wifi-bt Coex in Android 6.0.
+*
+******************************************************************************/
+#define LOG_TAG "rtk_parse"
+#define RTKBT_RELEASE_NAME	"Test"
+
+#include <utils/Log.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/un.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/prctl.h>
+#include <linux/types.h>
+#include <linux/netlink.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <dirent.h>
+#include <signal.h>
+#include <poll.h>
+
+#include "bt_list.h"
+#include "bt_hci_bdroid.h"
+#include "hci_layer.h"
+
+
+#include "rtk_parse.h"
+#include "hcidefs.h"
+#include <sys/syscall.h>
+
+#define RTK_VERSION "2.1"
+
+char invite_req[] = "INVITE_REQ";
+char invite_rsp[] = "INVITE_RSP";
+char attend_req[] = "ATTEND_REQ";
+char attend_ack[] = "ATTEND_ACK";
+char wifi_leave[] = "WIFI_LEAVE";
+char leave_ack[] =  "LEAVE_ACK";
+char bt_leave[] =   "BT_LEAVE";
+
+#define CONNECT_PORT        30001
+#define CONNECT_PORT_WIFI   30000
+//#define NETLINK_USER        31
+#define MAX_PAYLOAD         255 /* maximum payload size*/
+
+//L2CAP TYPE
+#define L2CAP_CONNECTION_REQ        0x02
+#define L2CAP_CONNECTION_RSP        0x03
+#define L2CAP_DISCONNECTION_REQ     0x06
+#define L2CAP_DISCONNECTION_RSP     0x07
+
+#define TIMER_A2DP_PACKET_COUNT     (SIGRTMAX -5)
+#define TIMER_PAN_PACKET_COUNT      (SIGRTMAX -6)
+#define TIMER_HOGP_PACKET_COUNT     (SIGRTMAX -7)
+#define TIMER_POLLING               (SIGRTMAX -8)
+
+#define PAN_PACKET_COUNT                5
+#define PACKET_COUNT_TIOMEOUT_VALUE     1000//ms
+
+//vendor cmd to fw
+#define HCI_VENDOR_ENABLE_PROFILE_REPORT_COMMAND        (0x0018 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VENDOR_SET_PROFILE_REPORT_COMMAND           (0x0019 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_VENDOR_MAILBOX_CMD                          (0x008F | HCI_GRP_VENDOR_SPECIFIC)
+
+#define HCI_VENDOR_ADD_BITPOOL_FW                       (0x0051 | HCI_GRP_VENDOR_SPECIFIC)
+
+//subcmd to fw for HCI_VENDOR_MAILBOX_CMD
+#define HCI_VENDOR_SUB_CMD_WIFI_CHANNEL_AND_BANDWIDTH_CMD   0x11
+#define HCI_VENDOR_SUB_CMD_WIFI_FORCE_TX_POWER_CMD          0x17
+#define HCI_VENDOR_SUB_CMD_BT_ENABLE_IGNORE_WLAN_ACT_CMD    0x1B
+#define HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO      0x23
+#define HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_STATUS_INFO       0x27
+#define HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_ENABLE            0x28
+#define HCI_VENDOR_SUB_CMD_BT_SET_TXRETRY_REPORT_PARAM      0x29
+#define HCI_VENDOR_SUB_CMD_BT_SET_PTATABLE                  0x2A
+#define HCI_VENDOR_SUB_CMD_SET_BT_PSD_MODE                  0x31
+#define HCI_VENDOR_SUB_CMD_SET_BT_LNA_CONSTRAINT            0x32
+#define HCI_VENDOR_SUB_CMD_GET_AFH_MAP_L                    0x40
+#define HCI_VENDOR_SUB_CMD_GET_AFH_MAP_M                    0x41
+#define HCI_VENDOR_SUB_CMD_GET_AFH_MAP_H                    0x42
+#define HCI_VENDOR_SUB_CMD_RD_REG_REQ                       0x43
+#define HCI_VENDOR_SUB_CMD_WR_REG_REQ                       0x44
+
+//sub event from fw
+#define HCI_VENDOR_PTA_REPORT_EVENT         0x24
+#define    HCI_VENDOR_PTA_AUTO_REPORT_EVENT    0x25
+
+//vendor cmd to wifi driver
+#define HCI_OP_HCI_EXTENSION_VERSION_NOTIFY (0x0100 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_BT_OPERATION_NOTIFY          (0x0102 | HCI_GRP_VENDOR_SPECIFIC)
+#define    HCI_OP_HCI_BT_INFO_NOTIFY           (0x0106 | HCI_GRP_VENDOR_SPECIFIC)
+#define    HCI_OP_HCI_BT_COEX_NOTIFY           (0x0107 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_HCI_BT_PATCH_VER_NOTIFY      (0x0108 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_HCI_BT_AFH_MAP_NOTIFY        (0x0109 | HCI_GRP_VENDOR_SPECIFIC)
+#define HCI_OP_HCI_BT_REGISTER_VALUE_NOTIFY (0x010a | HCI_GRP_VENDOR_SPECIFIC)
+
+//bt operation to notify for HCI_OP_BT_OPERATION_NOTIFY
+#define BT_OPCODE_NONE                  0
+#define BT_OPCODE_INQUIRY_START         1
+#define BT_OPCODE_INQUIRY_END           2
+#define BT_OPCODE_PAGE_START            3
+#define BT_OPCODE_PAGE_SUCCESS_END      4
+#define BT_OPCODE_PAGE_UNSUCCESS_END    5
+#define BT_OPCODE_PAIR_START            6
+#define BT_OPCODE_PAIR_END              7
+#define BT_OPCODE_ENABLE_BT             8
+#define BT_OPCODE_DISABLE_BT            9
+
+//bt info reason to wifi for HCI_OP_HCI_BT_INFO_NOTIFY
+#define HOST_RESPONSE                   0 //Host response when receive the BT Info Control Event
+#define POLLING_RESPONSE                1 //The BT Info response for polling by BT firmware.
+#define AUTO_REPORT                     2 //BT auto report by BT firmware.
+#define STACK_REPORT_WHILE_DEVICE_D2    3 //Stack report when BT firmware is under power save state(ex:D2)
+
+// vendor event from wifi
+#define RTK_HS_EXTENSION_EVENT_WIFI_SCAN            0x01
+#define RTK_HS_EXTENSION_EVENT_RADIO_STATUS_NOTIFY  0x02
+#define RTK_HS_EXTENSION_EVENT_HCI_BT_INFO_CONTROL  0x03
+#define RTK_HS_EXTENSION_EVENT_HCI_BT_COEX_CONTROL  0x04
+
+//op code from wifi for RTK_HS_EXTENSION_EVENT_HCI_BT_COEX_CONTROL
+#define BT_PATCH_VERSION_QUERY      0x00
+#define IGNORE_WLAN_ACTIVE_CONTROL  0x01
+#define LNA_CONSTRAIN_CONTROL       0x02
+#define BT_POWER_DECREASE_CONTROL   0x03
+#define BT_PSD_MODE_CONTROL         0x04
+#define WIFI_BW_CHNL_NOTIFY         0x05
+#define QUERY_BT_AFH_MAP            0x06
+#define BT_REGISTER_ACCESS          0x07
+
+#define HCI_EXTENSION_VERSION   0x0004
+
+#define HCI_CMD_PREAMBLE_SIZE   3
+
+#define PSM_SDP     0x0001
+#define PSM_RFCOMM  0x0003
+#define PSM_PAN     0x000F
+#define PSM_HID     0x0011
+#define PSM_HID_INT 0x0013
+#define PSM_AVCTP   0x0017
+#define PSM_AVDTP   0x0019
+#define PSM_FTP     0x1001
+#define PSM_BIP     0x1003
+#define PSM_OPP     0x1015
+//--Add more if needed--//
+
+enum {
+    profile_sco = 0,
+    profile_hid = 1,
+    profile_a2dp = 2,
+    profile_pan = 3,
+    profile_hid_interval = 4,
+    profile_hogp = 5,
+    profile_voice = 6,
+    profile_max = 7
+};
+
+//profile info data
+typedef struct RTK_PROF_INFO {
+    RT_LIST_ENTRY   list;
+    uint16_t        handle;
+    uint16_t        psm;
+    uint16_t        dcid;
+    uint16_t        scid;
+    uint8_t         profile_index;
+}tRTK_PROF_INFO;
+
+//profile info for each connection
+typedef struct RTK_CONN_PROF {
+    RT_LIST_ENTRY list;
+    uint16_t handle;
+    uint8_t type;                   //0:l2cap, 1:sco/esco, 2:le
+    uint8_t profile_bitmap;         //0:SCO, 1:HID, 2:A2DP, 3:FTP/PAN/OPP, 4: HID_interval, 5:HOGP, 6:VOICE
+    int8_t  profile_refcount[8];    //0:SCO, 1:HID, 2:A2DP, 3:FTP/PAN/OPP, 4:TBD, 5:HOGP, 6:VOICE
+}tRTK_CONN_PROF;
+
+//profile info for all
+typedef struct RTK_PROF {
+    RT_LIST_HEAD    conn_hash;      //hash for connections
+    RT_LIST_HEAD    profile_list;   //hash for profile info
+    pthread_mutex_t profile_mutex;
+    pthread_mutex_t udpsocket_mutex;
+    pthread_t thread_monitor;
+    pthread_t thread_data;
+    timer_t  timer_a2dp_packet_count;
+    timer_t  timer_pan_packet_count;
+    timer_t  timer_hogp_packet_count;
+    timer_t  timer_polling;
+    //struct sockaddr_nl src_addr;    //for netlink
+    struct sockaddr_in server_addr; //server addr for kernel socket
+    struct sockaddr_in client_addr; //client addr  for kernel socket
+    uint32_t a2dp_packet_count;
+    uint32_t pan_packet_count;
+    uint32_t hogp_packet_count;
+    uint32_t voice_packet_count;
+    uint8_t  profile_bitmap;
+    uint8_t  profile_status;
+    int8_t   profile_refcount[8];
+    uint8_t  ispairing;
+    uint8_t  isinquirying;
+    uint8_t  ispaging;
+    uint8_t  wifi_state;
+    uint8_t  autoreport;
+    uint8_t  polling_enable;
+    uint8_t  polling_interval;
+    volatile uint8_t udpsocket_recv_thread_running;
+    //int32_t   nlsocket;
+    int32_t   udpsocket;
+    uint8_t  piconet_id;
+    uint8_t  mode;
+    uint8_t  afh_map[10];
+    uint16_t hci_reversion;
+    uint16_t lmp_subversion;
+    uint8_t  wifi_on;
+    //uint8_t  le_profile_index;
+}tRTK_PROF;
+
+typedef struct HCI_RETURN_PARAMETER_MAILBOX_REGISTER {
+    uint8_t  type;
+    uint32_t offset;
+    uint32_t value;
+}tHCI_RETURN_PARAMETER_MAILBOX_REGISTER;
+
+typedef struct HCI_EVENT_BT_INFO_CONTROL {
+    uint8_t     polling_enable;
+    uint8_t     polling_time;
+    uint8_t     autoreport_enable;
+}tHCI_EVENT_BT_INFO_CONTROL;
+
+tRTK_PROF rtk_prof;
+volatile int poweroff_allowed = 0;
+uint8_t coex_log_enable = 0;
+static const hci_t *hci_interface;
+
+static const allocator_t *buffer_allocator;
+
+
+#define BIT(_I)                         (uint16_t)(1<<(_I))
+#define is_profile_connected(profile)   ((rtk_prof.profile_bitmap & BIT(profile)) >0)
+#define is_profile_busy(profile)        ((rtk_prof.profile_status & BIT(profile)) >0)
+
+static void timeout_handler(int signo, siginfo_t * info, void *context);
+
+#ifndef RTK_PARSE_LOG_BUF_SIZE
+#define RTK_PARSE_LOG_BUF_SIZE  1024
+#endif
+#define RTK_PARSE_LOG_MAX_SIZE  (RTK_PARSE_LOG_BUF_SIZE - 12)
+
+#define LOGI0(t,s) __android_log_write(ANDROID_LOG_INFO, t, s)
+static void LogMsg(const char *fmt_str, ...)
+{
+    static char buffer[RTK_PARSE_LOG_BUF_SIZE];
+    if(coex_log_enable)
+    {
+        va_list ap;
+        va_start(ap, fmt_str);
+        vsnprintf(&buffer[0], RTK_PARSE_LOG_MAX_SIZE, fmt_str, ap);
+        va_end(ap);
+
+        LOGI0("rtk_parse: ", buffer);
+    }
+    else
+    {
+        return;
+    }
+}
+
+static timer_t OsAllocateTimer(int signo)
+{
+    struct sigevent sigev;
+    timer_t timerid = (timer_t)-1;
+
+    // Create the POSIX timer to generate signo
+    sigev.sigev_notify = SIGEV_THREAD_ID;
+    sigev.sigev_notify_thread_id = syscall(__NR_gettid);
+    sigev.sigev_signo = signo;
+    sigev.sigev_value.sival_ptr = &timerid;
+
+    ALOGE("OsAllocateTimer rtk_parse sigev.sigev_notify_thread_id = syscall(__NR_gettid)!");
+
+    //Create the Timer using timer_create signal
+    if (timer_create(CLOCK_REALTIME, &sigev, &timerid) == 0)
+    {
+        return timerid;
+    }
+    else
+    {
+        ALOGE("timer_create error!");
+        return (timer_t)-1;
+    }
+}
+
+static int OsFreeTimer(timer_t timerid)
+{
+    int ret = 0;
+    ret = timer_delete(timerid);
+    if(ret != 0)
+        ALOGE("timer_delete fail with errno(%d)", errno);
+
+    return ret;
+}
+
+static int OsStartTimer(timer_t timerid, int msec, int mode)
+{
+    struct itimerspec itval;
+
+    itval.it_value.tv_sec = msec / 1000;
+    itval.it_value.tv_nsec = (long)(msec % 1000) * (1000000L);
+
+    if (mode == 1)
+    {
+        itval.it_interval.tv_sec  = itval.it_value.tv_sec;
+        itval.it_interval.tv_nsec = itval.it_value.tv_nsec;
+    }
+    else
+    {
+        itval.it_interval.tv_sec = 0;
+        itval.it_interval.tv_nsec = 0;
+    }
+
+    //Set the Timer when to expire through timer_settime
+    if (timer_settime(timerid, 0, &itval, NULL) != 0)
+    {
+        ALOGE("time_settime error!");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int OsStopTimer(timer_t timerid)
+{
+    return OsStartTimer(timerid, 0, 0);
+}
+
+int alloc_polling_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_POLLING, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_polling_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_polling= OsAllocateTimer(TIMER_POLLING);
+    LogMsg("alloc polling timer");
+
+    return 0;
+}
+
+int free_polling_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_polling);
+}
+
+int stop_polling_timer()
+{
+    LogMsg("stop polling timer");
+    return OsStopTimer(rtk_prof.timer_polling);
+}
+
+int start_polling_timer(int value)
+{
+    LogMsg("start polling timer");
+    return OsStartTimer(rtk_prof.timer_polling, value, 1);
+}
+
+int alloc_hogp_packet_count_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_HOGP_PACKET_COUNT, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_hogp_packet_count_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_hogp_packet_count= OsAllocateTimer(TIMER_HOGP_PACKET_COUNT);
+    LogMsg("alloc hogp packet");
+
+    return 0;
+}
+
+int free_hogp_packet_count_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_hogp_packet_count);
+}
+
+int stop_hogp_packet_count_timer()
+{
+    LogMsg("stop hogp packet");
+    return OsStopTimer(rtk_prof.timer_hogp_packet_count);
+}
+
+int start_hogp_packet_count_timer()
+{
+    LogMsg("start hogp packet");
+    return OsStartTimer(rtk_prof.timer_hogp_packet_count, PACKET_COUNT_TIOMEOUT_VALUE, 1);
+}
+
+int alloc_a2dp_packet_count_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_A2DP_PACKET_COUNT, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_a2dp_packet_count_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_a2dp_packet_count= OsAllocateTimer(TIMER_A2DP_PACKET_COUNT);
+    LogMsg("alloc a2dp packet");
+
+    return 0;
+}
+
+int free_a2dp_packet_count_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_a2dp_packet_count);
+}
+
+int stop_a2dp_packet_count_timer()
+{
+    LogMsg("stop a2dp packet");
+    return OsStopTimer(rtk_prof.timer_a2dp_packet_count);
+}
+
+int start_a2dp_packet_count_timer()
+{
+    LogMsg("start a2dp packet");
+    return OsStartTimer(rtk_prof.timer_a2dp_packet_count, PACKET_COUNT_TIOMEOUT_VALUE, 1);
+}
+
+int alloc_pan_packet_count_timer()
+{
+    struct sigaction sigact;
+
+    sigemptyset(&sigact.sa_mask);
+    sigact.sa_flags = SA_SIGINFO;
+
+    //register the Signal Handler
+    sigact.sa_sigaction = timeout_handler;
+
+    // Set up sigaction to catch signal first timer
+    if (sigaction(TIMER_PAN_PACKET_COUNT, &sigact, NULL) == -1)
+    {
+        ALOGE("alloc_pan_packet_count_timer, sigaction failed");
+        return -1;
+    }
+
+    // Create and set the timer when to expire
+    rtk_prof.timer_pan_packet_count= OsAllocateTimer(TIMER_PAN_PACKET_COUNT);
+
+    LogMsg("alloc pan packet");
+    return 0;
+}
+
+int free_pan_packet_count_timer()
+{
+    return OsFreeTimer(rtk_prof.timer_pan_packet_count);
+}
+
+int stop_pan_packet_count_timer()
+{
+    LogMsg("stop pan packet");
+    return OsStopTimer(rtk_prof.timer_pan_packet_count);
+}
+
+int start_pan_packet_count_timer()
+{
+    LogMsg("start pan packet");
+    return OsStartTimer(rtk_prof.timer_pan_packet_count, PACKET_COUNT_TIOMEOUT_VALUE, 1);
+}
+
+static int8_t psm_to_profile_index(uint16_t psm)
+{
+    switch (psm) {
+        case PSM_AVCTP:
+        case PSM_SDP:
+            return -1;   //ignore
+
+        case PSM_HID:
+        case PSM_HID_INT:
+            return profile_hid;
+
+        case PSM_AVDTP:
+            return profile_a2dp;
+
+        case PSM_PAN:
+        case PSM_OPP:
+        case PSM_FTP:
+        case PSM_BIP:
+        case PSM_RFCOMM:
+            return profile_pan;
+
+        default:
+            return profile_pan;
+    }
+}
+
+tRTK_CONN_PROF* find_connection_by_handle(tRTK_PROF* h5, uint16_t handle)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_CONN_PROF* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if ((handle & 0xEFF) == desc->handle )  //only last 12 bit are meanful for hci handle
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+tRTK_CONN_PROF* allocate_connection_by_handle(uint16_t handle)
+{
+    tRTK_CONN_PROF * phci_conn = NULL;
+    phci_conn = malloc(sizeof(tRTK_CONN_PROF));
+    if(phci_conn)
+        phci_conn->handle = handle;
+
+    return phci_conn;
+}
+
+void init_connection_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    ListInitializeHeader(head);
+}
+
+void add_connection_to_hash(tRTK_PROF* h5, tRTK_CONN_PROF* desc)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    ListAddToTail(&desc->list, head);
+}
+
+void delete_connection_from_hash(tRTK_CONN_PROF* desc)
+{
+    if (desc)
+    {
+        ListDeleteNode(&desc->list);
+        free(desc);
+    }
+}
+
+void flush_connection_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->conn_hash;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_CONN_PROF* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if (desc)
+        {
+            ListDeleteNode(&desc->list);
+            free(desc);
+        }
+    }
+    //ListInitializeHeader(head);
+}
+
+void init_profile_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    ListInitializeHeader(head);
+}
+
+uint8_t list_allocate_add(uint16_t handle, uint16_t psm, int8_t profile_index, uint16_t dcid, uint16_t scid)
+{
+    tRTK_PROF_INFO* pprof_info = NULL;
+
+    if(profile_index < 0)
+    {
+        ALOGE("PSM(0x%x) do not need parse", psm);
+        return FALSE;
+    }
+
+    pprof_info = malloc(sizeof(tRTK_PROF_INFO));
+    if (NULL == pprof_info)
+    {
+        ALOGE("list_allocate_add: allocate error");
+        return FALSE;
+    }
+
+    pprof_info->handle = handle;
+    pprof_info->psm = psm;
+    pprof_info->scid = scid;
+    pprof_info->dcid = dcid;
+    pprof_info->profile_index = profile_index;
+
+    ListAddToTail(&(pprof_info->list), &(rtk_prof.profile_list));
+
+    return TRUE;
+}
+
+void delete_profile_from_hash(tRTK_PROF_INFO* desc)
+{
+    LogMsg("delete profile for handle: %x, psm:%x, dcid:%x, scid:%x", desc->handle, desc->psm, desc->dcid, desc->scid);
+    if (desc)
+    {
+        ListDeleteNode(&desc->list);
+        free(desc);
+        desc = NULL;
+    }
+}
+
+void flush_profile_hash(tRTK_PROF* h5)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        delete_profile_from_hash(desc);
+    }
+    //ListInitializeHeader(head);
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+}
+
+tRTK_PROF_INFO* find_profile_by_handle_scid(tRTK_PROF* h5, uint16_t handle, uint16_t scid)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        if (((handle & 0xFFF) == desc->handle ) && (scid == desc->scid))
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+tRTK_PROF_INFO* find_profile_by_handle_dcid(tRTK_PROF* h5, uint16_t handle, uint16_t dcid)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        if (((handle & 0xFFF) == desc->handle ) && (dcid == desc->dcid))
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+tRTK_PROF_INFO* find_profile_by_handle_dcid_scid(tRTK_PROF* h5, uint16_t handle, uint16_t dcid, uint16_t scid)
+{
+    RT_LIST_HEAD* head = &h5->profile_list;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_PROF_INFO* desc = NULL;
+
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        desc = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+        if (((handle & 0xFFF) == desc->handle ) && (dcid == desc->dcid) && (scid == desc->scid))
+        {
+            return desc;
+        }
+    }
+    return NULL;
+}
+
+void rtk_vendor_cmd_to_fw(uint16_t opcode, uint8_t parameter_len, uint8_t* parameter)
+{
+    uint8_t temp = 0;
+    HC_BT_HDR  *p_buf=NULL;
+
+    if(buffer_allocator)
+        p_buf = (HC_BT_HDR *) buffer_allocator->alloc(BT_HC_HDR_SIZE + HCI_CMD_PREAMBLE_SIZE + parameter_len);
+
+    if(NULL == p_buf)
+    {
+        ALOGE("rtk_vendor_cmd_to_fw: HC_BT_HDR alloc error");
+        return;
+    }
+    p_buf->event = MSG_STACK_TO_HC_HCI_CMD;
+    p_buf->offset = 0;
+    p_buf->len = HCI_CMD_PREAMBLE_SIZE + parameter_len;
+    p_buf->layer_specific = 0;
+
+    uint8_t *p = (uint8_t *) (p_buf + 1);
+    UINT16_TO_STREAM(p, opcode);
+    LogMsg("rtk_vendor_cmd_to_fw: Opcode:%x",opcode);
+
+    if(parameter_len > 0)
+    {
+        *p++ = parameter_len;
+        memcpy(p, parameter, parameter_len);
+    }
+    if(hci_interface)
+    {
+            ALOGE("hci_interface->transmit_command Opcode:%x",opcode);
+            hci_interface->transmit_command((BT_HDR *)p_buf, NULL,NULL,NULL);
+    }
+    return ;
+}
+
+void rtk_notify_profileinfo_to_fw()
+{
+    RT_LIST_HEAD* head = NULL;
+    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+    tRTK_CONN_PROF* hci_conn = NULL;
+    uint8_t  handle_number = 0;
+    uint32_t buffer_size = 0;
+    uint8_t *p_buf = NULL;
+
+    head = &rtk_prof.conn_hash;
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        hci_conn = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if (hci_conn && hci_conn->profile_bitmap)
+            handle_number++;
+    }
+
+    buffer_size = 1 + handle_number*3 + 1;
+
+    if(buffer_allocator)
+        p_buf = (uint8_t *) buffer_allocator->alloc(buffer_size);
+
+    if(NULL == p_buf)
+    {
+        ALOGE("rtk_notify_profileinfo_to_fw: alloc error");
+        return;
+    }
+    uint8_t *p = (uint8_t *)p_buf;
+
+    LogMsg("rtk_notify_profileinfo_to_fw, BufferSize is %x", buffer_size);
+    *p++ = handle_number;
+    LogMsg("rtk_notify_profileinfo_to_fw, NumberOfHandles is %x", handle_number);
+    head = &rtk_prof.conn_hash;
+    LIST_FOR_EACH_SAFELY(iter, temp, head)
+    {
+        hci_conn = LIST_ENTRY(iter, tRTK_CONN_PROF, list);
+        if (hci_conn && hci_conn->profile_bitmap)
+        {
+            UINT16_TO_STREAM(p, hci_conn->handle);
+            LogMsg("rtk_notify_profileinfo_to_fw, handle is %x",hci_conn->handle);
+            *p++ = hci_conn->profile_bitmap;
+            LogMsg("rtk_notify_profileinfo_to_fw, profile_bitmap is %x",hci_conn->profile_bitmap);
+            handle_number --;
+        }
+        if(0 == handle_number)
+            break;
+    }
+
+    *p++ = rtk_prof.profile_status;
+    LogMsg("rtk_notify_profileinfo_to_fw, profile_status is %x",rtk_prof.profile_status);
+
+    rtk_vendor_cmd_to_fw(HCI_VENDOR_SET_PROFILE_REPORT_COMMAND, buffer_size, p_buf);
+
+    if(buffer_allocator)
+       buffer_allocator->free(p_buf);
+
+    return ;
+}
+
+void update_profile_state(uint8_t profile_index, uint8_t is_busy)
+{
+    uint8_t need_update = FALSE;
+
+    if((rtk_prof.profile_bitmap & BIT(profile_index)) == 0)
+    {
+        ALOGE("update_profile_state: ERROR!!! profile(Index: %x) does not exist", profile_index);
+        return;
+    }
+
+    if(is_busy)
+    {
+        if((rtk_prof.profile_status & BIT(profile_index)) == 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_status |= BIT(profile_index);
+        }
+    }
+    else
+    {
+        if((rtk_prof.profile_status & BIT(profile_index)) > 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_status &= ~(BIT(profile_index));
+        }
+    }
+
+    if(need_update)
+    {
+        LogMsg("update_profile_state, rtk_prof.profie_bitmap = %x", rtk_prof.profile_bitmap);
+        LogMsg("update_profile_state, rtk_prof.profile_status = %x", rtk_prof.profile_status);
+        rtk_notify_profileinfo_to_fw();
+    }
+}
+
+void rtk_check_setup_timer(int8_t profile_index)
+{
+    if(profile_index == profile_a2dp) {
+        rtk_prof.a2dp_packet_count = 0;
+        start_a2dp_packet_count_timer();
+    }
+    if(profile_index == profile_pan) {
+        rtk_prof.pan_packet_count = 0;
+        start_pan_packet_count_timer();
+    }
+    //hogp & voice share one timer now
+    if((profile_index == profile_hogp) || (profile_index == profile_voice)) {
+        if((0 == rtk_prof.profile_refcount[profile_hogp])
+                && (0 == rtk_prof.profile_refcount[profile_voice])) {
+            rtk_prof.hogp_packet_count = 0;
+            rtk_prof.voice_packet_count = 0;
+            start_hogp_packet_count_timer();
+        }
+    }
+}
+
+void rtk_check_del_timer(int8_t profile_index)
+{
+    if(profile_a2dp == profile_index)
+    {
+        rtk_prof.a2dp_packet_count = 0;
+        stop_a2dp_packet_count_timer();
+    }
+    if(profile_pan == profile_index)
+    {
+        rtk_prof.pan_packet_count = 0;
+        stop_pan_packet_count_timer();
+    }
+    if(profile_hogp == profile_index)
+    {
+        rtk_prof.hogp_packet_count = 0;
+        if(rtk_prof.profile_refcount[profile_voice] == 0)
+            stop_hogp_packet_count_timer();
+    }
+    if(profile_voice == profile_index)
+    {
+        rtk_prof.voice_packet_count = 0;
+        if(rtk_prof.profile_refcount[profile_hogp] == 0)
+            stop_hogp_packet_count_timer();
+    }
+}
+void update_profile_connection(tRTK_CONN_PROF * phci_conn, int8_t profile_index, uint8_t is_add)
+{
+    uint8_t need_update = FALSE;
+    int kk = 0;
+
+    LogMsg("update_profile_connection: is_add=%d, psm_index=%d", is_add, profile_index);
+    if (profile_index < 0)
+        return;
+
+    if(is_add)
+    {
+        if(rtk_prof.profile_refcount[profile_index] == 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_bitmap |= BIT(profile_index);
+
+            //SCO is always busy
+            if(profile_index == profile_sco)
+                rtk_prof.profile_status |= BIT(profile_index);
+
+            rtk_check_setup_timer(profile_index);
+        }
+        rtk_prof.profile_refcount[profile_index]++;
+
+        if(0 == phci_conn->profile_refcount[profile_index])
+        {
+            need_update = TRUE;
+            phci_conn->profile_bitmap |= BIT(profile_index);
+        }
+        phci_conn->profile_refcount[profile_index]++;
+    }
+    else
+    {
+        rtk_prof.profile_refcount[profile_index]--;
+        LogMsg("for test: --, rtk_prof.profile_refcount[%x] = %x", profile_index, rtk_prof.profile_refcount[profile_index]);
+        if(rtk_prof.profile_refcount[profile_index] == 0)
+        {
+            need_update = TRUE;
+            rtk_prof.profile_bitmap &= ~(BIT(profile_index));
+
+            //If profile does not exist, Status is meaningless
+            rtk_prof.profile_status &= ~(BIT(profile_index));
+            rtk_check_del_timer(profile_index);
+        }
+
+        phci_conn->profile_refcount[profile_index]--;
+        if(0 == phci_conn->profile_refcount[profile_index])
+        {
+            need_update = TRUE;
+            phci_conn->profile_bitmap &= ~(BIT(profile_index));
+
+            //clear profile_hid_interval if need
+            if(profile_hid == profile_index)
+            {
+                if((phci_conn->profile_bitmap &(BIT(profile_hid_interval))))
+                {
+                    phci_conn->profile_bitmap &= ~(BIT(profile_hid_interval));
+                    rtk_prof.profile_refcount[profile_hid_interval]--;
+                }
+            }
+        }
+    }
+
+    if(need_update)
+    {
+        LogMsg("update_profile_connection: rtk_h5.profile_bitmap = %x", rtk_prof.profile_bitmap);
+        for(kk=0; kk<8; kk++)
+            LogMsg("update_profile_connection: rtk_h5.profile_refcount[%d] = %d", kk, rtk_prof.profile_refcount[kk]);
+        rtk_notify_profileinfo_to_fw();
+    }
+}
+
+void update_hid_active_state(uint16_t handle, uint16_t interval)
+{
+    uint8_t need_update = 0;
+    LogMsg("update_hid_active_state: handle = %x, interval = 0x%x", handle, interval);
+    tRTK_CONN_PROF *phci_conn = find_connection_by_handle(&rtk_prof, handle);
+
+    if(phci_conn == NULL)
+        return;
+
+    if(((phci_conn->profile_bitmap)&(BIT(profile_hid))) == 0)
+    {
+        LogMsg("hid not connected in the handle, nothing to be down");
+        return;
+    }
+
+    if(interval < 60)
+    {
+        if((phci_conn->profile_bitmap &(BIT(profile_hid_interval))) == 0)
+        {
+            need_update = 1;
+            phci_conn->profile_bitmap |= BIT(profile_hid_interval);
+
+            rtk_prof.profile_refcount[profile_hid_interval]++;
+            if(rtk_prof.profile_refcount[profile_hid_interval] == 1)
+                rtk_prof.profile_status |= BIT(profile_hid);
+        }
+    }
+    else
+    {
+        if((phci_conn->profile_bitmap &(BIT(profile_hid_interval))))
+        {
+            need_update = 1;
+            phci_conn->profile_bitmap &= ~(BIT(profile_hid_interval));
+
+            rtk_prof.profile_refcount[profile_hid_interval]--;
+            if(rtk_prof.profile_refcount[profile_hid_interval] == 0)
+                rtk_prof.profile_status &= ~(BIT(profile_hid));
+        }
+    }
+
+    if(need_update)
+        rtk_notify_profileinfo_to_fw();
+}
+uint8_t handle_l2cap_con_req(uint16_t handle, uint16_t psm, uint16_t scid, uint8_t direction)
+{
+    uint8_t status = FALSE;
+    tRTK_PROF_INFO* prof_info = NULL;
+
+    int8_t profile_index = psm_to_profile_index(psm);
+
+    if(profile_index < 0) {
+        LogMsg("PSM(0x%x) do not need parse", psm);
+        return status;
+    }
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    if(direction)//1: out
+        prof_info = find_profile_by_handle_scid(&rtk_prof, handle, scid);
+    else // 0:in
+        prof_info = find_profile_by_handle_dcid(&rtk_prof, handle, scid);
+
+    if(prof_info)
+    {
+        LogMsg("handle_l2cap_con_req: This profile is already exist!!!");
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return status;
+    }
+
+    if(direction)//1: out
+        status = list_allocate_add(handle, psm, profile_index, 0, scid);
+    else // 0:in
+        status = list_allocate_add(handle, psm, profile_index, scid, 0);
+
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+
+    if (!status)
+        ALOGE("handle_l2cap_con_req: list_allocate_add failed!");
+
+    return status;
+}
+
+uint8_t handle_l2cap_con_rsp(uint16_t handle, uint16_t dcid, uint16_t scid, uint8_t direction, uint8_t result)
+{
+    tRTK_PROF_INFO* prof_info = NULL;
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    if(!direction)//0, in
+        prof_info = find_profile_by_handle_scid(&rtk_prof, handle, scid);
+    else //1, out
+        prof_info = find_profile_by_handle_dcid(&rtk_prof, handle, scid);
+
+    if (!prof_info)
+    {
+        //LogMsg("handle_l2cap_con_rsp: prof_info Not Find!!");
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return 0;
+    }
+
+    if(!result)//success
+    {
+        LogMsg("l2cap connection success, update connection");
+        if(!direction)//0, in
+            prof_info->dcid = dcid;
+        else//1, out
+            prof_info->scid = dcid;
+
+        tRTK_CONN_PROF *phci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(phci_conn)
+            update_profile_connection(phci_conn, prof_info->profile_index, TRUE);
+    }
+
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+    return 1;
+}
+
+uint8_t handle_l2cap_discon_req(uint16_t handle, uint16_t dcid, uint16_t scid, uint8_t direction)
+{
+    tRTK_PROF_INFO* prof_info = NULL;
+    LogMsg("l2cap_discon_req, handle = %x, dcid = %x, scid = %x, direction = %x", handle, dcid, scid, direction);
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    if(!direction)//0: in
+        prof_info = find_profile_by_handle_dcid_scid(&rtk_prof, handle, scid, dcid);
+    else //1: out
+        prof_info = find_profile_by_handle_dcid_scid(&rtk_prof, handle, dcid, scid);
+
+    if (!prof_info)
+    {
+        //LogMsg("handle_l2cap_discon_req: prof_info Not Find!");
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return 0;
+    }
+
+    tRTK_CONN_PROF *phci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(NULL == phci_conn)
+    {
+        pthread_mutex_unlock(&rtk_prof.profile_mutex);
+        return 0;
+    }
+
+    update_profile_connection(phci_conn, prof_info->profile_index, FALSE);
+    delete_profile_from_hash(prof_info);
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+
+    return 1;
+}
+
+void packets_count(uint16_t handle, uint16_t scid, uint16_t length, uint8_t direction)
+{
+    tRTK_PROF_INFO* prof_info = NULL;
+    uint8_t profile_type;
+
+    tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(NULL == hci_conn)
+        return;
+
+    if(0 == hci_conn->type)//l2cap
+    {
+        if(!direction)    //0: in
+            prof_info = find_profile_by_handle_scid(&rtk_prof, handle, scid);
+        else //1: out
+            prof_info = find_profile_by_handle_dcid(&rtk_prof, handle, scid);
+
+        if(!prof_info)
+        {
+            //LogMsg("packets_count: prof_info Not Find!");
+            //ALOGE("handle=%x, scid=%x, length=%d,",handle, scid, length);
+            return ;
+        }
+
+        if((prof_info->profile_index == profile_a2dp) && (length > 100))//avdtp media data
+        {
+            if(!is_profile_busy(profile_a2dp))
+                update_profile_state(profile_a2dp, TRUE);
+            rtk_prof.a2dp_packet_count++;
+        }
+
+        if(prof_info->profile_index == profile_pan)
+            rtk_prof.pan_packet_count++;
+    }
+}
+
+static void timeout_handler(int signo, siginfo_t * info, void *context)
+{
+    if (signo == TIMER_POLLING)
+    {
+        LogMsg("polling timeout");
+        if(rtk_prof.polling_enable)
+        {
+            uint8_t temp_cmd[1];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 1, temp_cmd);
+        }
+    }
+    else if (signo == TIMER_A2DP_PACKET_COUNT)
+    {
+        LogMsg("count a2dp packet timeout, a2dp_packet_count = %d",rtk_prof.a2dp_packet_count);
+        if(rtk_prof.a2dp_packet_count == 0)
+        {
+            if(is_profile_busy(profile_a2dp))
+            {
+                LogMsg("timeout_handler: a2dp busy->idle!");
+                update_profile_state(profile_a2dp, FALSE);
+            }
+        }
+        rtk_prof.a2dp_packet_count = 0;
+    }
+    else if (signo == TIMER_HOGP_PACKET_COUNT)
+    {
+        LogMsg("count hogp packet timeout, hogp_packet_count = %d",rtk_prof.hogp_packet_count);
+        if(rtk_prof.hogp_packet_count == 0)
+        {
+            if(is_profile_busy(profile_hogp))
+            {
+                LogMsg("timeout_handler: hogp busy->idle!");
+                update_profile_state(profile_hogp, FALSE);
+            }
+        }
+        rtk_prof.hogp_packet_count = 0;
+
+        LogMsg("count hogp packet timeout, voice_packet_count = %d",rtk_prof.voice_packet_count);
+        if(rtk_prof.voice_packet_count == 0)
+        {
+            if(is_profile_busy(profile_voice))
+            {
+                LogMsg("timeout_handler: voice busy->idle!");
+                update_profile_state(profile_voice, FALSE);
+            }
+        }
+        rtk_prof.voice_packet_count = 0;
+    }
+    else if (signo == TIMER_PAN_PACKET_COUNT)
+    {
+        LogMsg("count pan packet timeout, pan_packet_count = %d",rtk_prof.pan_packet_count);
+        if(rtk_prof.pan_packet_count < PAN_PACKET_COUNT)
+        {
+            if(is_profile_busy(profile_pan))
+            {
+                LogMsg("timeout_handler: pan busy->idle!");
+                update_profile_state(profile_pan, FALSE);
+            }
+        }
+        else
+        {
+            if(!is_profile_busy(profile_pan))
+            {
+                LogMsg("timeout_handler: pan idle->busy!");
+                update_profile_state(profile_pan, TRUE);
+            }
+        }
+        rtk_prof.pan_packet_count = 0;
+    }
+    else
+    {
+        ALOGE("rtk_parse_data timer unspported signo(%d)", signo);
+    }
+}
+
+#if 0
+int netlink_send(int nlsk, char *buffer)
+{
+    struct nlmsghdr* nlhdr;
+    struct iovec iov;
+    struct msghdr msg;
+    struct sockaddr_nl nladdr;
+
+    if(nlsk <= 0)
+        return -1;
+
+    memset(&msg, 0 ,sizeof(struct msghdr));
+    memset(&nladdr, 0 ,sizeof(struct sockaddr_nl));
+
+    nlhdr = (struct nlmsghdr *)malloc(NLMSG_SPACE(strlen(buffer) + 1));
+    strcpy(NLMSG_DATA(nlhdr),buffer);
+
+    nlhdr->nlmsg_len = NLMSG_LENGTH(strlen(buffer) + 1);
+    nlhdr->nlmsg_pid = getpid(); //sender pid
+    nlhdr->nlmsg_flags = NLM_F_REQUEST;
+    nlhdr->nlmsg_type = NLMSG_MIN_TYPE;
+
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pid = 0; //send to kernel
+    nladdr.nl_groups = 0;
+
+    iov.iov_base = (void *)nlhdr;
+    iov.iov_len = nlhdr->nlmsg_len;
+
+    msg.msg_iov = &iov;
+    msg.msg_iovlen = 1;
+    msg.msg_name = (void *)&(nladdr);
+    msg.msg_namelen = sizeof(nladdr);
+
+    return sendmsg(nlsk, &msg, 0);
+}
+#endif
+
+int udpsocket_send(char *tx_msg, int msg_size)
+{
+    int n; /* message byte size */
+
+    LogMsg("udpsocket_send tx_msg:%s",tx_msg);
+    n = sendto(rtk_prof.udpsocket, tx_msg, msg_size, 0, (struct sockaddr *) &rtk_prof.client_addr, sizeof(rtk_prof.client_addr));
+    if (n < 0)
+    {
+        ALOGE("ERROR in sendto");
+        return -1;
+    }
+    return 0;
+}
+
+int udpsocket_recv(uint8_t *recv_msg, uint8_t *msg_size)
+{
+    struct hostent *hostp;  /* client host info */
+    char buf[MAX_PAYLOAD];  /* message buf */
+    char *hostaddrp;        /* dotted decimal host addr string */
+    int n;                  /* message byte size */
+    struct sockaddr_in recv_addr;
+    socklen_t clientlen = sizeof(recv_addr);
+    struct pollfd pfd = {
+        .events = POLLPRI | POLLIN,
+        .revents = 0,
+        .fd = rtk_prof.udpsocket
+    };
+
+    bzero(buf, MAX_PAYLOAD);
+
+    while (poll(&pfd, 1, 1000) <= 0) {
+        if (rtk_prof.udpsocket_recv_thread_running ==0) {
+            LogMsg("SIGUSR2 should have caught us before this");
+            return -1;
+        }
+    }
+
+
+    n = recvfrom(rtk_prof.udpsocket, buf, MAX_PAYLOAD, 0, (struct sockaddr *) &recv_addr, &clientlen);
+    if (n < 0) {
+        ALOGE("ERROR in recvfrom");
+        return -1;
+    } else {
+        *msg_size = n;
+        memcpy(recv_msg,buf,n);
+    }
+    return 0;
+}
+
+void rtk_notify_extension_version_to_wifi()
+{
+    uint8_t para_length = 2;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_EXTENSION_VERSION_NOTIFY);
+    *p++ = para_length;
+    UINT16_TO_STREAM(p, HCI_EXTENSION_VERSION);
+    LogMsg("extension version is 0x%x", HCI_EXTENSION_VERSION);
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_extension_version_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_btpatch_version_to_wifi()
+{
+    uint8_t para_length = 4;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_PATCH_VER_NOTIFY);
+    *p++ = para_length;
+    UINT16_TO_STREAM(p, rtk_prof.hci_reversion);
+    UINT16_TO_STREAM(p, rtk_prof.lmp_subversion);
+    LogMsg("btpatch_version, length is 0x%x, hci_reversion is 0x%x, lmp_subversion is %x", para_length, rtk_prof.hci_reversion, rtk_prof.lmp_subversion);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_btpatch_version_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_afhmap_to_wifi()
+{
+    uint8_t para_length = 13;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_AFH_MAP_NOTIFY);
+    *p++ = para_length;
+    *p++ = rtk_prof.piconet_id;
+    *p++ = rtk_prof.mode;
+    *p++ = 10;
+    memcpy(p, rtk_prof.afh_map, 10);
+
+    LogMsg("afhmap, piconet_id is 0x%x, map type is 0x%x", rtk_prof.piconet_id, rtk_prof.mode);
+    uint8_t kk = 0;
+    for(kk=0; kk < 10; kk++)
+        LogMsg("afhmap data[%d] is 0x%x", kk, rtk_prof.afh_map[kk]);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_afhmap_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_btcoex_to_wifi(uint8_t opcode, uint8_t status)
+{
+    uint8_t para_length = 2;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_COEX_NOTIFY);
+    *p++ = para_length;
+    *p++ = opcode;
+    if(!status)
+        *p++ = 0;
+    else
+        *p++ = 1;
+
+    LogMsg("btcoex, opcode is 0x%x, status is 0x%x", opcode, status);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_btcoex_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_btoperation_to_wifi(uint8_t operation, uint8_t append_data_length, uint8_t *append_data)
+{
+    uint8_t para_length = 3 + append_data_length;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_BT_OPERATION_NOTIFY);
+    *p++ = para_length;
+    *p++ = operation;
+    *p++ = append_data_length;
+    if(append_data_length)
+        memcpy(p, append_data, append_data_length);
+
+    LogMsg("btoperation, opration is 0x%x, append_data_length is 0x%x", operation, append_data_length);
+    uint8_t kk = 0;
+    if(append_data_length)
+    {
+        for(kk=0; kk < append_data_length; kk++)
+            LogMsg("append data is 0x%x", *(append_data+kk));
+    }
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_btoperation_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_info_to_wifi(uint8_t reason, uint8_t length, uint8_t* report_info)
+{
+    uint8_t para_length = 4 + length;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+    int i;
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_INFO_NOTIFY);
+    *p++ = para_length;
+    *p++ = rtk_prof.polling_enable;
+    *p++ = rtk_prof.polling_interval;
+    *p++ = reason;
+    *p++ = length;
+
+    if(length)
+        memcpy(p, report_info, length);
+
+    LogMsg("bt info, length is 0x%x, polling_enable is 0x%x, poiiling_interval is %x",para_length, rtk_prof.polling_enable, rtk_prof.polling_interval);
+    LogMsg("bt info, reason is 0x%x, info length is 0x%x", reason, length);
+    if(length)
+    {
+        for(i=0;i<length;i++)
+            LogMsg("bt info[%d]: %02x", i, report_info[i]); 
+    }
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_info_to_wifi: udpsocket send error");
+}
+
+void rtk_notify_regester_to_wifi(uint8_t* reg_value)
+{
+    uint8_t para_length = 9;
+    char p_buf[para_length + HCI_CMD_PREAMBLE_SIZE];
+
+    if(!rtk_prof.wifi_on)
+        return;
+
+    char *p = p_buf;
+    UINT16_TO_STREAM(p, HCI_OP_HCI_BT_REGISTER_VALUE_NOTIFY);
+    *p++ = para_length;
+    memcpy(p, reg_value, para_length);
+
+    tHCI_RETURN_PARAMETER_MAILBOX_REGISTER *reg = (tHCI_RETURN_PARAMETER_MAILBOX_REGISTER *)reg_value;
+    LogMsg("bt register, register type is %x", reg->type);
+    LogMsg("bt register, register offset is %x", reg->offset);
+    LogMsg("bt register, register value is %x", reg->value);
+
+    if(udpsocket_send(p_buf, para_length + HCI_CMD_PREAMBLE_SIZE) < 0)
+        ALOGE("rtk_notify_regester_to_wifi: udpsocket send error");
+}
+
+static void rtk_handle_bt_info_control(uint8_t* p)
+{
+    tHCI_EVENT_BT_INFO_CONTROL*  info = (tHCI_EVENT_BT_INFO_CONTROL*)p;
+    uint8_t temp_cmd[3];
+
+    LogMsg("rtk_prof.polling_enable is %x",rtk_prof.polling_enable);
+    LogMsg("receive bt info control event from wifi, polling enable is 0x%x, polling time is 0x%x, auto report is 0x%x",
+                    info->polling_enable, info->polling_time, info->autoreport_enable);
+
+    if(info->polling_enable && !rtk_prof.polling_enable)
+        start_polling_timer(info->polling_time * 1000);
+
+    if(!info->polling_enable && rtk_prof.polling_enable)
+        stop_polling_timer();
+
+    rtk_prof.polling_enable = info->polling_enable;
+    rtk_prof.polling_interval = info->polling_time;
+    rtk_prof.autoreport = info->autoreport_enable;
+
+    temp_cmd[0] = HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_ENABLE;
+    temp_cmd[1] = 1;
+    temp_cmd[2] = info->autoreport_enable;
+    rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+
+    rtk_notify_info_to_wifi(HOST_RESPONSE, 0, NULL);
+}
+
+static void rtk_handle_bt_coex_control(uint8_t* p)
+{
+    uint8_t opcode = *p++;
+    LogMsg("receive bt coex control event from wifi, opration is 0x%x", opcode);
+    switch (opcode)
+    {
+        case BT_PATCH_VERSION_QUERY:
+        {
+            rtk_notify_btpatch_version_to_wifi();
+            break;
+        }
+
+        case IGNORE_WLAN_ACTIVE_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t value = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_BT_ENABLE_IGNORE_WLAN_ACT_CMD;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = value;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case LNA_CONSTRAIN_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t value = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_SET_BT_LNA_CONSTRAINT;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = value;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case BT_POWER_DECREASE_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t power_decrease = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_WIFI_FORCE_TX_POWER_CMD;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = power_decrease;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case BT_PSD_MODE_CONTROL:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t psd_mode = *p++;
+            uint8_t temp_cmd[3];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_SET_BT_PSD_MODE;
+            temp_cmd[1] = 1;
+            temp_cmd[2] = psd_mode;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 3, temp_cmd);
+            break;
+        }
+
+        case WIFI_BW_CHNL_NOTIFY:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t temp_cmd[5];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_WIFI_CHANNEL_AND_BANDWIDTH_CMD;
+            temp_cmd[1] = 3;
+            memcpy(temp_cmd+2, p, 3);//wifi_state, wifi_centralchannel, chnnels_btnotuse
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 5, temp_cmd);
+            break;
+        }
+
+        case QUERY_BT_AFH_MAP:
+        {
+            uint8_t opcode_len = *p++;
+            rtk_prof.piconet_id = *p++;
+            rtk_prof.mode = *p++;
+            uint8_t temp_cmd[4];
+            temp_cmd[0] = HCI_VENDOR_SUB_CMD_GET_AFH_MAP_L;
+            temp_cmd[1] = 2;
+            temp_cmd[2] = rtk_prof.piconet_id;
+            temp_cmd[3] = rtk_prof.mode;
+            rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 4, temp_cmd);
+            break;
+        }
+
+        case BT_REGISTER_ACCESS:
+        {
+            uint8_t opcode_len = *p++;
+            uint8_t access_type = *p++;
+            if(access_type == 0) //read
+            {
+                uint8_t temp_cmd[7];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_RD_REG_REQ;
+                temp_cmd[1] = 5;
+                temp_cmd[2] = *p++;
+                memcpy(temp_cmd+3, p, 4);
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 7, temp_cmd);
+            }
+            else //write
+            {
+                uint8_t temp_cmd[11];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_RD_REG_REQ;
+                temp_cmd[1] = 5;
+                temp_cmd[2] = *p++;
+                memcpy(temp_cmd+3, p, 8);
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 11, temp_cmd);
+            }
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+void rtk_handle_event_from_wifi(uint8_t* msg)
+{
+    uint8_t *p = msg;
+    uint8_t event_code = *p++;
+
+    if(memcmp(msg, invite_rsp, sizeof(invite_rsp)) == 0)
+    {
+#if 0
+        LogMsg("receive invite rsp from wifi, close netlink socket if needed");
+        if(rtk_prof.nlsocket > 0)
+        {
+            close(rtk_prof.nlsocket);
+            LogMsg("close netlink socket %d", rtk_prof.nlsocket);
+        }
+#endif
+        LogMsg("receive invite rsp from wifi, wifi is already on");
+        rtk_prof.wifi_on = 1;
+        rtk_notify_extension_version_to_wifi();
+    }
+
+    if(memcmp(msg, attend_req, sizeof(attend_req)) == 0)
+    {
+        LogMsg("receive attend req from wifi, wifi turn on");
+        rtk_prof.wifi_on = 1;
+        udpsocket_send(attend_ack, sizeof(attend_ack));
+        rtk_notify_extension_version_to_wifi();
+    }
+
+    if(memcmp(msg, wifi_leave, sizeof(wifi_leave)) == 0)
+    {
+        LogMsg("receive wifi leave from wifi, wifi turn off");
+        rtk_prof.wifi_on = 0;
+        udpsocket_send(leave_ack, sizeof(leave_ack));
+        if(rtk_prof.polling_enable)
+        {
+            rtk_prof.polling_enable = 0;
+            stop_polling_timer();
+        }
+    }
+
+    if(memcmp(msg, leave_ack, sizeof(leave_ack)) == 0)
+    {
+        LogMsg("receive leave ack from wifi");
+    }
+
+    if(event_code == 0xFE)
+    {
+        uint8_t total_length = *p++;
+        uint8_t extension_event = *p++;
+        switch(extension_event)
+        {
+            case  RTK_HS_EXTENSION_EVENT_WIFI_SCAN:
+            {
+                uint8_t operation = *p;
+                LogMsg("receive wifi scan notify evnet from wifi, operation is 0x%x", operation);
+                break;
+            }
+
+            case  RTK_HS_EXTENSION_EVENT_HCI_BT_INFO_CONTROL:
+            {
+                rtk_handle_bt_info_control(p);
+                break;
+            }
+
+            case RTK_HS_EXTENSION_EVENT_HCI_BT_COEX_CONTROL:
+            {
+                rtk_handle_bt_coex_control(p);
+                break;
+            }
+
+            default:
+                break;
+        }
+    }
+
+    if(event_code == 0x0E)
+    {
+        uint16_t wifi_opcode;
+        uint8_t op_status;
+        p += 2;//length, number of complete packets
+        STREAM_TO_UINT16(wifi_opcode, p);
+        op_status = *p;
+        LogMsg("receive command complete event from wifi, op code is 0x%x, status is 0x%x", wifi_opcode, op_status);
+    }
+}
+
+static void udpsocket_receive_thread_exit_handler(int sig)
+{
+    LogMsg("USR2, this signal is %d \n", sig);
+    usleep(100);
+    pthread_exit(0);
+}
+
+static void udpsocket_receive_thread(void *arg)
+{
+    uint8_t msg_recv[MAX_PAYLOAD];
+    uint8_t recv_length;
+    struct sigaction actions;
+
+    memset(&actions, 0, sizeof(actions));
+    sigemptyset(&actions.sa_mask);
+    actions.sa_flags = 0;
+    actions.sa_handler = udpsocket_receive_thread_exit_handler;
+
+    int rc = sigaction(SIGUSR2,&actions,NULL);
+
+    LogMsg("udpsocket_receive_thread started");
+    prctl(PR_SET_NAME, (unsigned long)"udpsocket_receive_thread", 0, 0, 0);
+
+    while(rtk_prof.udpsocket_recv_thread_running)
+    {
+        memset(msg_recv, 0 , MAX_PAYLOAD);
+        if (udpsocket_recv(msg_recv, &recv_length) == 0)
+            rtk_handle_event_from_wifi(msg_recv);
+    }
+
+    LogMsg("udpsocket_receive_thread exiting");
+    pthread_exit(NULL);
+}
+
+int create_udpsocket_socket()
+{
+    int portno = CONNECT_PORT;
+    int optval; /* flag value for setsockopt */
+
+    LogMsg("create udpsocket port: %d\n", portno);
+
+    pthread_mutex_lock(&rtk_prof.udpsocket_mutex);
+
+    pthread_attr_t thread_attr_data;
+    if (rtk_prof.udpsocket_recv_thread_running)
+    {
+        ALOGE("udp_receive_thread already exit");
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+
+    rtk_prof.udpsocket_recv_thread_running = 1;
+    rtk_prof.udpsocket = socket(AF_INET, SOCK_DGRAM, 0);
+    LogMsg("create socket %d", rtk_prof.udpsocket);
+
+    if (rtk_prof.udpsocket < 0)
+    {
+        ALOGE("create udpsocket error...%s\n", strerror(errno));
+        rtk_prof.udpsocket_recv_thread_running = 0;
+        close(rtk_prof.udpsocket);
+        LogMsg("close socket %d", rtk_prof.udpsocket);
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+
+    bzero((char *) &rtk_prof.server_addr, sizeof(rtk_prof.server_addr));
+    rtk_prof.server_addr.sin_family = AF_INET;
+    rtk_prof.server_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    rtk_prof.server_addr.sin_port = htons(CONNECT_PORT);
+
+    bzero((char *) &rtk_prof.client_addr, sizeof(rtk_prof.client_addr));
+    rtk_prof.client_addr.sin_family = AF_INET;
+    rtk_prof.client_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    rtk_prof.client_addr.sin_port = htons(CONNECT_PORT_WIFI);
+
+    optval = 1;
+    setsockopt(rtk_prof.udpsocket, SOL_SOCKET, SO_REUSEADDR, (const void *)&optval , sizeof(int));
+
+    if (bind(rtk_prof.udpsocket, (struct sockaddr *)&rtk_prof.server_addr, sizeof(rtk_prof.server_addr)) < 0)
+    {
+        ALOGE("bind udpsocket error...%s\n", strerror(errno));
+        rtk_prof.udpsocket_recv_thread_running = 0;
+        close(rtk_prof.udpsocket);
+        LogMsg("close socket %d", rtk_prof.udpsocket);
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+
+    pthread_attr_init(&thread_attr_data);
+    if (pthread_create(&rtk_prof.thread_data, &thread_attr_data, (void*)udpsocket_receive_thread, NULL) != 0)
+    {
+        ALOGE("pthread_create failed!");
+        pthread_attr_destroy(&thread_attr_data);
+        rtk_prof.udpsocket_recv_thread_running = 0;
+        pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+        return -1 ;
+    }
+    pthread_attr_destroy(&thread_attr_data);
+    pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+    return 0;
+}
+
+int stop_udpsocket_receive_thread()
+{
+    pthread_mutex_lock(&rtk_prof.udpsocket_mutex);
+    int result = 0;
+
+    LogMsg("notify wifi bt turn off");
+    if(rtk_prof.wifi_on)
+        udpsocket_send(bt_leave, sizeof(bt_leave));
+
+    if (rtk_prof.udpsocket_recv_thread_running)
+    {
+        LogMsg("data thread is running, stop it");
+
+        //add for pthread_cancel
+        if ((result = pthread_kill(rtk_prof.thread_data, SIGUSR2)) != 0)
+        {
+            ALOGE("error cancelling data thread");
+        }
+        rtk_prof.udpsocket_recv_thread_running = 0;
+
+        if ((result = pthread_join(rtk_prof.thread_data, NULL)) < 0)
+        {
+            ALOGE( "data thread pthread_join() failed result:%d", result);
+        }
+
+        LogMsg("close socket %d", rtk_prof.udpsocket);
+        if((result = close(rtk_prof.udpsocket)) != 0)
+        {
+            ALOGE("close socket error!");
+        }
+    }
+    pthread_mutex_unlock(&rtk_prof.udpsocket_mutex);
+    return 0;
+}
+
+#if 0
+int create_netlink_socket()
+{
+    LogMsg("in creat netlink socket");
+    rtk_prof.nlsocket = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
+
+    if (rtk_prof.nlsocket < 0)
+    {
+        ALOGE("create netlink socket error...%s\n", strerror(errno));
+        close(rtk_prof.nlsocket);
+        LogMsg("close netlink socket %d", rtk_prof.nlsocket);
+        return -1 ;
+    }
+    LogMsg("create netlink socket %d", rtk_prof.nlsocket);
+    memset(&rtk_prof.src_addr, 0, sizeof(rtk_prof.src_addr));
+    rtk_prof.src_addr.nl_family = AF_NETLINK;
+    rtk_prof.src_addr.nl_pid = getpid(); /* self pid */
+    rtk_prof.src_addr.nl_groups    = 0 ;    /* not in mcast groups */
+    int ret = bind(rtk_prof.nlsocket, (struct sockaddr *)&rtk_prof.src_addr, sizeof(rtk_prof.src_addr));
+    if(ret < 0)
+    {
+        ALOGE("bind netlink socket error...%s\n", strerror(errno));
+        close(rtk_prof.nlsocket);
+        LogMsg("close netlink socket %d", rtk_prof.nlsocket);
+        return -1 ;
+    }
+
+    return 0;
+}
+#endif
+
+void rtk_parse_init(hci_t *hci_if)
+{
+    ALOGI("RTKBT_RELEASE_NAME: %s",RTKBT_RELEASE_NAME);
+    LogMsg("rtk_profile_init, version: %s", RTK_VERSION);
+
+    pthread_mutex_init(&rtk_prof.profile_mutex, NULL);
+    pthread_mutex_init(&rtk_prof.udpsocket_mutex, NULL);
+    alloc_a2dp_packet_count_timer();
+    alloc_pan_packet_count_timer();
+    alloc_hogp_packet_count_timer();
+    alloc_polling_timer();
+
+    init_profile_hash(&rtk_prof);
+    init_connection_hash(&rtk_prof);
+
+    create_udpsocket_socket();
+    hci_interface = hci_if;
+}
+
+void rtk_parse_cleanup()
+{
+    LogMsg("rtk_profile_cleanup");
+    int kk = 0;
+    free_a2dp_packet_count_timer();
+    free_pan_packet_count_timer();
+    free_hogp_packet_count_timer();
+    free_polling_timer();
+
+    flush_connection_hash(&rtk_prof);
+    flush_profile_hash(&rtk_prof);
+    pthread_mutex_destroy(&rtk_prof.profile_mutex);
+
+    stop_udpsocket_receive_thread();
+    pthread_mutex_destroy(&rtk_prof.udpsocket_mutex);
+
+    rtk_prof.polling_enable = 0;
+    rtk_prof.profile_bitmap = 0;
+    rtk_prof.profile_status = 0;
+    for(kk = 0; kk < 8; kk++)
+        rtk_prof.profile_refcount[kk] = 0;
+}
+
+static void rtk_handle_vender_mailbox_cmp_evt(uint8_t* p, uint8_t len)
+{
+    uint8_t status = *p++;
+    if(len <= 4)
+    {
+        LogMsg("receive mailbox cmd from fw, total length <= 4");
+        return;
+    }
+    uint8_t subcmd = *p++;
+    LogMsg("receive mailbox cmd from fw, subcmd is 0x%x, status is 0x%x", subcmd, status);
+    switch(subcmd)
+    {
+        case HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO:
+            if(status == 0) //success
+            {
+                if((len-5) != 8)
+                    LogMsg("rtk_handle_vender_mailbox_cmp_evt:HCI_VENDOR_SUB_CMD_BT_REPORT_CONN_SCO_INQ_INFO len=%d", len);
+                rtk_notify_info_to_wifi(POLLING_RESPONSE, (len-5), (uint8_t*)p);
+            }
+            break;
+
+        case HCI_VENDOR_SUB_CMD_WIFI_CHANNEL_AND_BANDWIDTH_CMD:
+            rtk_notify_btcoex_to_wifi(WIFI_BW_CHNL_NOTIFY, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_WIFI_FORCE_TX_POWER_CMD:
+            rtk_notify_btcoex_to_wifi(BT_POWER_DECREASE_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_ENABLE_IGNORE_WLAN_ACT_CMD:
+            rtk_notify_btcoex_to_wifi(IGNORE_WLAN_ACTIVE_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_SET_BT_PSD_MODE:
+            rtk_notify_btcoex_to_wifi(BT_PSD_MODE_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_SET_BT_LNA_CONSTRAINT:
+            rtk_notify_btcoex_to_wifi(LNA_CONSTRAIN_CONTROL, status);
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_AUTO_REPORT_ENABLE:
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_SET_TXRETRY_REPORT_PARAM:
+            break;
+
+        case HCI_VENDOR_SUB_CMD_BT_SET_PTATABLE:
+            break;
+
+        case HCI_VENDOR_SUB_CMD_GET_AFH_MAP_L:
+        {
+            if(status == 0)//success
+            {
+                memcpy(rtk_prof.afh_map, p+4, 4); //cmd_idx, length, piconet_id, mode
+                uint8_t temp_cmd[4];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_GET_AFH_MAP_M;
+                temp_cmd[1] = 2;
+                temp_cmd[2] = rtk_prof.piconet_id;
+                temp_cmd[3] = rtk_prof.mode;
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 4, temp_cmd);
+            }
+            else //fail
+            {
+                memset(rtk_prof.afh_map, 0, 10);
+                rtk_notify_afhmap_to_wifi();
+            }
+            break;
+        }
+        case HCI_VENDOR_SUB_CMD_GET_AFH_MAP_M:
+        {
+            if(status == 0)//success
+            {
+                memcpy(rtk_prof.afh_map+4, p+4, 4);
+                uint8_t temp_cmd[4];
+                temp_cmd[0] = HCI_VENDOR_SUB_CMD_GET_AFH_MAP_H;
+                temp_cmd[1] = 2;
+                temp_cmd[2] = rtk_prof.piconet_id;
+                temp_cmd[3] = rtk_prof.mode;
+                rtk_vendor_cmd_to_fw(HCI_VENDOR_MAILBOX_CMD, 4, temp_cmd);
+            }
+            else //fail
+            {
+                memset(rtk_prof.afh_map, 0, 10);
+                rtk_notify_afhmap_to_wifi();
+            }
+            break;
+        }
+
+        case HCI_VENDOR_SUB_CMD_GET_AFH_MAP_H:
+        {
+            if(status == 0)
+                memcpy(rtk_prof.afh_map+8, p+4, 2);
+            else
+                memset(rtk_prof.afh_map, 0, 10);
+
+            rtk_notify_afhmap_to_wifi();
+            break;
+        }
+
+        case HCI_VENDOR_SUB_CMD_RD_REG_REQ:
+        {
+            if(status == 0)
+                rtk_notify_regester_to_wifi(p+3);//cmd_idx,length,regist type
+            break;
+        }
+
+        case HCI_VENDOR_SUB_CMD_WR_REG_REQ:
+            rtk_notify_btcoex_to_wifi(BT_REGISTER_ACCESS, status);
+            break;
+
+        default:
+            break;
+    }
+}
+
+static void rtk_handle_cmd_complete_evt(uint8_t*p, uint8_t len)
+{
+    uint16_t opcode;
+    uint8_t status;
+    p++;
+    STREAM_TO_UINT16(opcode, p);
+    switch (opcode)
+    {
+        case HCI_PERIODIC_INQUIRY_MODE:
+        {
+            status = *p++;
+            if(status && rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 0;
+                LogMsg("HCI_PERIODIC_INQUIRY_MODE start error, notify wifi inquiry stop");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_READ_LOCAL_VERSION_INFO:
+        {
+            status = *p++;
+            if(!status)
+            {
+                p++;
+                STREAM_TO_UINT16(rtk_prof.hci_reversion, p);
+                p+=3;
+                STREAM_TO_UINT16(rtk_prof.lmp_subversion, p);
+            }
+            LogMsg("rtk_prof.hci_reversion = %x", rtk_prof.hci_reversion);
+            LogMsg("rtk_prof.lmp_subversion = %x", rtk_prof.lmp_subversion);
+            break;
+        }
+
+        case HCI_RESET:
+        {
+            LogMsg("bt start ok");
+            udpsocket_send(invite_req, sizeof(invite_req));
+#if 0
+            if(create_netlink_socket() == 0)
+            {
+                LogMsg("wifi is already on when bt turn on");
+                rtk_prof.wifi_on = 1;
+                netlink_send(rtk_prof.nlsocket, invite_req);
+            }
+            else
+                LogMsg("wifi is off when bt turn on, wait for wifi turning on...");
+#endif
+            uint8_t ttmp[1] = {1};
+            rtk_vendor_cmd_to_fw(0xfc1b, 1, ttmp);
+            break;
+        }
+
+        case 0xfc1b:
+            LogMsg("received cmd complete event for fc1b");
+            poweroff_allowed = 1;
+            break;
+
+        case HCI_VENDOR_MAILBOX_CMD:
+            rtk_handle_vender_mailbox_cmp_evt(p, len);
+            break;
+
+        case HCI_VENDOR_ADD_BITPOOL_FW:
+            status = *p++;
+            LogMsg("received cmd complete event for HCI_VENDOR_ADD_BITPOOL_FW status:%d",status);
+
+        default:
+            break;
+    }
+}
+
+static void rtk_handle_connection_complete_evt(uint8_t* p)
+{
+    uint8_t status = 0;
+    uint16_t handle = 0;
+    status = *p++;
+    STREAM_TO_UINT16 (handle, p);
+    p +=6;
+    uint8_t link_type = *p++;
+
+    if(status == 0)
+    {
+        if(rtk_prof.ispaging)
+        {
+            rtk_prof.ispaging = 0;
+            LogMsg("notify wifi page success end");
+            rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_SUCCESS_END, 0, NULL);
+        }
+
+        tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(hci_conn == NULL)
+        {
+            hci_conn = allocate_connection_by_handle(handle);
+            if(hci_conn)
+            {
+                add_connection_to_hash(&rtk_prof, hci_conn);
+                hci_conn->profile_bitmap = 0;
+                memset(hci_conn->profile_refcount, 0, 8);
+                if((0 == link_type) ||(2 == link_type))//sco or esco
+                {
+                    hci_conn->type = 1;
+                    update_profile_connection(hci_conn, profile_sco, TRUE);
+                }
+                else
+                    hci_conn->type = 0;
+            }
+            else
+            {
+                ALOGE("HciConnAllocate fail");
+            }
+        }
+        else
+        {
+            LogMsg("HCI Connection handle(0x%x) has already exist!", handle);
+            hci_conn->profile_bitmap = 0;
+            memset(hci_conn->profile_refcount, 0, 8);
+            if((0 == link_type)||(2 == link_type))//sco or esco
+            {
+                hci_conn->type = 1;
+                update_profile_connection(hci_conn, profile_sco, TRUE);
+            }
+            else
+                hci_conn->type = 0;
+        }
+    }
+    else if(rtk_prof.ispaging)
+    {
+        rtk_prof.ispaging = 0;
+        LogMsg("notify wifi page unsuccess end");
+        rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_UNSUCCESS_END, 0, NULL);
+    }
+}
+
+static void rtk_handle_disconnect_complete_evt(uint8_t* p)
+{
+    if(rtk_prof.ispairing)//for slave: connection will be disconnected if authentication fail
+    {
+        rtk_prof.ispairing = 0;
+        LogMsg("notify wifi pair end");
+        rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_END, 0, NULL);
+    }
+
+    uint8_t status = 0;
+    uint16_t handle = 0;
+    uint8_t reason = 0;
+    status = *p++;
+    STREAM_TO_UINT16(handle, p);
+    reason = *p;
+
+    if(status == 0)
+    {
+        tRTK_CONN_PROF *hci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(hci_conn)
+        {
+            switch(hci_conn->type)
+            {
+                case 0:
+                {
+                    RT_LIST_ENTRY* iter = NULL, *temp = NULL;
+                    tRTK_PROF_INFO* prof_info = NULL;
+
+                    pthread_mutex_lock(&rtk_prof.profile_mutex);
+                    LIST_FOR_EACH_SAFELY(iter, temp, &rtk_prof.profile_list)
+                    {
+                        prof_info = LIST_ENTRY(iter, tRTK_PROF_INFO, list);
+                        if ((handle == prof_info->handle) && prof_info->scid && prof_info->dcid)
+                        {
+                            LogMsg("find info when hci disconnect, handle:%x, psm:%x, dcid:%x, scid:%x", prof_info->handle, prof_info->psm, prof_info->dcid, prof_info->scid);
+                            //If both scid and dcid > 0, L2cap connection is exist.
+                            update_profile_connection(hci_conn, prof_info->profile_index, FALSE);
+                            delete_profile_from_hash(prof_info);
+                        }
+                    }
+                    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+                    break;
+                }
+
+                case 1:
+                    update_profile_connection(hci_conn, profile_sco, FALSE);
+                    break;
+
+                case 2:
+                {
+                    if(hci_conn->profile_bitmap & BIT(profile_hogp))
+                        update_profile_connection(hci_conn, profile_hogp, FALSE);
+
+                    if(hci_conn->profile_bitmap & BIT(profile_voice))
+                        update_profile_connection(hci_conn, profile_voice, FALSE);
+
+                    update_profile_connection(hci_conn, profile_hid, FALSE);
+                    break;
+                }
+
+                default:
+                    break;
+            }
+            delete_connection_from_hash(hci_conn);
+        }
+        else
+        {
+            ALOGE("HCI Connection handle(0x%x) not found", handle);
+        }
+    }
+}
+
+static void rtk_handle_le_connection_complete_evt(uint8_t* p)
+{
+    uint16_t handle, interval;
+    uint8_t status;
+    tRTK_CONN_PROF* hci_conn = NULL;
+
+    status = *p++;
+    STREAM_TO_UINT16 (handle, p);
+    p += 8; //role, address type, address
+    STREAM_TO_UINT16 (interval, p);
+
+    if(status == 0) {
+        if(rtk_prof.ispaging){
+            rtk_prof.ispaging = 0;
+            LogMsg("notify wifi page success end");
+            rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_SUCCESS_END, 0, NULL);
+        }
+
+        hci_conn = find_connection_by_handle(&rtk_prof, handle);
+        if(hci_conn == NULL) {
+            hci_conn = allocate_connection_by_handle(handle);
+            if(hci_conn) {
+                add_connection_to_hash(&rtk_prof, hci_conn);
+                hci_conn->profile_bitmap = 0;
+                memset(hci_conn->profile_refcount, 0, 8);
+                hci_conn->type = 2;
+                update_profile_connection(hci_conn, profile_hid, TRUE); //for coex, le is the same as hid
+                update_hid_active_state(handle, interval);
+            } else {
+                ALOGE("hci connection allocate fail");
+            }
+        } else {
+            LogMsg("hci connection handle(0x%x) has already exist!", handle);
+            hci_conn->profile_bitmap = 0;
+            memset(hci_conn->profile_refcount, 0, 8);
+            hci_conn->type = 2;
+            update_profile_connection(hci_conn, profile_hid, TRUE);
+            update_hid_active_state(handle, interval);
+        }
+    } else if(rtk_prof.ispaging) {
+        rtk_prof.ispaging = 0;
+        LogMsg("notify wifi page unsuccess end");
+        rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_UNSUCCESS_END, 0, NULL);
+    }
+}
+
+static void rtk_handle_le_connection_update_complete_evt(uint8_t* p)
+{
+    uint16_t handle, interval;
+    uint8_t status;
+
+    status = *p++;
+    STREAM_TO_UINT16 (handle, p);
+    STREAM_TO_UINT16 (interval, p);
+    update_hid_active_state(handle, interval);
+}
+
+static void rtk_handle_le_meta_evt(uint8_t* p)
+{
+    uint8_t sub_event = *p++;
+    switch (sub_event) {
+    case HCI_BLE_CONN_COMPLETE_EVT:
+        rtk_handle_le_connection_complete_evt(p);
+        break;
+
+    case HCI_BLE_LL_CONN_PARAM_UPD_EVT:
+        rtk_handle_le_connection_update_complete_evt(p);
+        break;
+
+    default :
+        break;
+    }
+}
+
+void rtk_parse_internal_event_intercept(uint8_t *p_msg)
+{
+    //ALOGE("in rtk_parse_internal_event_intercept, *p= %x", *p);
+    uint8_t *p = p_msg;
+    uint8_t event_code = *p++;
+    uint8_t len = *p++;
+    uint16_t opcode, mode_change_handle, mode_interval, subcode;
+    uint8_t status, num_hci_cmd_pkts;
+
+    switch (event_code)
+    {
+        case HCI_INQUIRY_COMP_EVT:
+        {
+            if(rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 0;
+                LogMsg("notify wifi inquiry end");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_PIN_CODE_REQUEST_EVT:
+        {
+            if(!rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 1;
+                LogMsg("notify wifi pair start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_START, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_IO_CAPABILITY_REQUEST_EVT:
+        {
+            if(!rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 1;
+                LogMsg("notify wifi pair start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_START, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_AUTHENTICATION_COMP_EVT:
+        {
+            if(rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 0;
+                LogMsg("notify wifi pair end");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_LINK_KEY_NOTIFICATION_EVT:
+        {
+            if(rtk_prof.ispairing)
+            {
+                rtk_prof.ispairing = 0;
+                LogMsg("notify wifi pair end");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAIR_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_MODE_CHANGE_EVT:
+        {
+            status = *p++;
+            STREAM_TO_UINT16(mode_change_handle, p);
+            p++;
+            STREAM_TO_UINT16(mode_interval, p);
+            update_hid_active_state(mode_change_handle, mode_interval);
+            break;
+        }
+
+        case HCI_COMMAND_COMPLETE_EVT:
+            rtk_handle_cmd_complete_evt(p, len);
+            break;
+
+        case HCI_COMMAND_STATUS_EVT:
+        {
+            status = *p++;
+            num_hci_cmd_pkts = *p++;
+            STREAM_TO_UINT16(opcode, p);
+            if((opcode == HCI_INQUIRY) && (status))
+            {
+                if(rtk_prof.isinquirying)
+                {
+                    rtk_prof.isinquirying = 0;
+                    LogMsg("inquiry start error, notify wifi inquiry stop");
+                    rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+                }
+            }
+
+            if(opcode == HCI_CREATE_CONNECTION)
+            {
+                if(!status && !rtk_prof.ispaging)
+                {
+                    rtk_prof.ispaging = 1;
+                    LogMsg("notify wifi start page");
+                    rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_START, 0, NULL);
+                }
+            }
+            break;
+        }
+
+        case HCI_CONNECTION_COMP_EVT:
+        case HCI_ESCO_CONNECTION_COMP_EVT:
+            rtk_handle_connection_complete_evt(p);
+            break;
+
+        case HCI_DISCONNECTION_COMP_EVT:
+            rtk_handle_disconnect_complete_evt(p);
+            break;
+
+        case HCI_VENDOR_SPECIFIC_EVT:
+        {
+            STREAM_TO_UINT16(subcode, p);
+            if(subcode == HCI_VENDOR_PTA_AUTO_REPORT_EVENT)
+            {
+                LogMsg("notify wifi driver with autoreport data");
+                if((len-2) != 8)
+                    LogMsg("rtk_parse_internal_event_intercept:HCI_VENDOR_SPECIFIC_EVT:HCI_VENDOR_PTA_AUTO_REPORT_EVENT len=%d", len);
+                rtk_notify_info_to_wifi(AUTO_REPORT, (len-2), (uint8_t *)p);
+            }
+            break;
+        }
+
+        case HCI_BLE_EVENT:
+            rtk_handle_le_meta_evt(p);
+            break;
+
+        default:
+            break;
+    }
+}
+
+void rtk_parse_command(uint8_t *pp)
+{
+    uint8_t *p =pp;
+    uint16_t cmd;
+    STREAM_TO_UINT16(cmd, p);
+
+    switch (cmd)
+    {
+        case HCI_INQUIRY:
+        case HCI_PERIODIC_INQUIRY_MODE:
+        {
+            if(!rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 1;
+                LogMsg("notify wifi inquiry start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_START, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_INQUIRY_CANCEL:
+        case HCI_EXIT_PERIODIC_INQUIRY_MODE:
+        {
+            if(rtk_prof.isinquirying)
+            {
+                rtk_prof.isinquirying = 0;
+                LogMsg("notify wifi inquiry stop");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_INQUIRY_END, 0, NULL);
+            }
+            break;
+        }
+
+        case HCI_ACCEPT_CONNECTION_REQUEST:
+        {
+            if(!rtk_prof.ispaging)
+            {
+                rtk_prof.ispaging = 1;
+                LogMsg("notify wifi page start");
+                rtk_notify_btoperation_to_wifi(BT_OPCODE_PAGE_START, 0, NULL);
+            }
+            break;
+        }
+
+        default:
+            break;
+    }
+}
+
+void rtk_parse_l2cap_data(uint8_t *pp, uint8_t direction)
+{
+    uint16_t handle, total_len, pdu_len, channel_ID, command_len, psm, scid, dcid, result, status;
+    uint8_t flag, code, identifier;
+    STREAM_TO_UINT16 (handle, pp);
+    flag = handle >> 12;
+    handle = handle & 0x0FFF;
+    STREAM_TO_UINT16 (total_len, pp);
+    STREAM_TO_UINT16 (pdu_len, pp);
+    STREAM_TO_UINT16 (channel_ID, pp);
+
+    if(channel_ID == 0x0001)
+    {
+        code = (uint8_t)(*pp++);
+        switch (code)
+        {
+            case L2CAP_CONNECTION_REQ:
+                identifier = (uint8_t)(*pp++);
+                STREAM_TO_UINT16 (command_len, pp);
+                STREAM_TO_UINT16 (psm, pp);
+                STREAM_TO_UINT16 (scid, pp);
+                LogMsg("L2CAP_CONNECTION_REQ, handle=%x, PSM=%x, scid=%x", handle, psm, scid);
+                handle_l2cap_con_req(handle, psm, scid, direction);
+                break;
+
+            case L2CAP_CONNECTION_RSP:
+                identifier = (uint8_t)(*pp++);
+                STREAM_TO_UINT16 (command_len, pp);
+                STREAM_TO_UINT16 (dcid, pp);
+                STREAM_TO_UINT16 (scid, pp);
+                STREAM_TO_UINT16 (result, pp);
+                STREAM_TO_UINT16 (status, pp);
+                LogMsg("L2CAP_CONNECTION_RESP, handle=%x, dcid=%x, scid=%x, result=%x", handle, dcid, scid, result);
+                //if(result == 0)
+                    handle_l2cap_con_rsp(handle, dcid, scid, direction, result);
+                break;
+
+            case L2CAP_DISCONNECTION_REQ:
+                identifier = (uint8_t)(*pp++);
+                STREAM_TO_UINT16 (command_len, pp);
+                STREAM_TO_UINT16 (dcid, pp);
+                STREAM_TO_UINT16 (scid, pp);
+                LogMsg("L2CAP_DISCONNECTION_REQ, handle=%x, dcid=%x, scid=%x",handle, dcid, scid);
+                handle_l2cap_discon_req(handle, dcid, scid, direction);
+                break;
+
+            case L2CAP_DISCONNECTION_RSP:
+                break;
+
+            default:
+                break;
+        }
+    }
+    else
+    {
+        if((flag != 0x01)&&(is_profile_connected(profile_a2dp) || is_profile_connected(profile_pan)))//Do not count the continuous packets
+            packets_count(handle, channel_ID, pdu_len, direction);
+    }
+}
+
+void rtk_add_le_profile(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map)
+{
+    LogMsg("rtk_add_le_profile, handle is %x, profile_map is %x", handle, profile_map);
+
+    tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(hci_conn)
+    {
+        if((profile_map & 0x01) || (profile_map & 0x02))//bit0: mouse, bit1:keyboard
+            update_profile_connection(hci_conn, profile_hogp, TRUE);
+
+        if(profile_map & 0x04)
+            update_profile_connection(hci_conn, profile_voice, TRUE);
+    }
+    else
+    {
+        ALOGE("rtk_add_le_profile, connection handle(0x%x) not exist!", handle);
+    }
+}
+
+void rtk_delete_le_profile(BD_ADDR bdaddr, uint16_t handle, uint8_t profile_map)
+{
+    LogMsg("rtk_delete_le_profile, handle is %x, profile_map is %x", handle, profile_map);
+
+    pthread_mutex_lock(&rtk_prof.profile_mutex);
+    tRTK_CONN_PROF* hci_conn = find_connection_by_handle(&rtk_prof, handle);
+    if(hci_conn == NULL)
+    {
+        ALOGE("rtk_delete_le_profile, hci_conn not exist with handle %x", handle);
+    }
+    else
+    {
+        if((profile_map & 0x01) || (profile_map & 0x02))//bit0: mouse, bit1:keyboard
+            update_profile_connection(hci_conn, profile_hogp, FALSE);
+
+        if(profile_map & 0x04)
+            update_profile_connection(hci_conn, profile_voice, FALSE);
+    }
+    pthread_mutex_unlock(&rtk_prof.profile_mutex);
+}
+
+void rtk_add_le_data_count(uint8_t data_type)
+{
+    LogMsg("rtk_add_le_data_count, data_type is %x", data_type);
+
+    if((data_type == 1) || (data_type == 2))//1:keyboard, 2:mouse
+    {
+        rtk_prof.hogp_packet_count++;
+        if(!is_profile_busy(profile_hogp))
+        {
+            LogMsg("hogp idle->busy");
+            update_profile_state(profile_hogp, TRUE);
+        }
+    }
+
+    if(data_type == 3)//voice
+    {
+        rtk_prof.voice_packet_count ++;
+        if(!is_profile_busy(profile_voice))
+        {
+            LogMsg("voice idle->busy");
+            update_profile_state(profile_voice, TRUE);
+        }
+    }
+}
+
+void rtk_add_bitpool_to_fw(uint8_t bitpool)
+{
+    uint8_t temp_cmd[1];
+    ALOGE("rtk_add_bitpool_to_fw bitpool:%d", bitpool);
+    temp_cmd[0] = bitpool;
+    rtk_vendor_cmd_to_fw(HCI_VENDOR_ADD_BITPOOL_FW, 1, temp_cmd);
+}
+
+static const rtk_parse_manager_t interface = {
+  rtk_parse_internal_event_intercept,
+  rtk_parse_l2cap_data,
+  rtk_parse_init,
+  rtk_parse_cleanup,
+  rtk_parse_command,
+  rtk_add_le_profile,
+  rtk_delete_le_profile,
+  rtk_add_le_data_count,
+  rtk_add_bitpool_to_fw,
+};
+
+const rtk_parse_manager_t *rtk_parse_manager_get_interface() {
+  buffer_allocator = buffer_allocator_get_interface();
+  return &interface;
+}
+
+
diff --git a/hci/src/vendor.c b/hci/src/vendor.c
old mode 100644
new mode 100755
index c6bbd43..cb8640e
--- a/hci/src/vendor.c
+++ b/hci/src/vendor.c
@@ -30,6 +30,11 @@
 #include "osi/include/osi.h"
 
 
+#ifdef BLUETOOTH_RTK
+#include "bdroid_buildcfg.h"
+static const char *VENDOR_LIBRARY_NAME_USB = "libbt-vendor_usb.so";
+static const char *VENDOR_LIBRARY_NAME_UART = "libbt-vendor_uart.so";
+#endif
 static const char *VENDOR_LIBRARY_NAME = "libbt-vendor.so";
 static const char *VENDOR_LIBRARY_SYMBOL_NAME = "BLUETOOTH_VENDOR_LIB_INTERFACE";
 
@@ -50,11 +55,29 @@ static bool vendor_open(
   assert(lib_handle == NULL);
   hci = hci_interface;
 
+#ifdef BLUETOOTH_RTK
+  if(!bluetooth_rtk_h5_flag ) {
+    lib_handle = dlopen(VENDOR_LIBRARY_NAME_USB,RTLD_NOW);
+    if (!lib_handle) {
+        ALOGE("%s unable to open %s: %s", __func__, VENDOR_LIBRARY_NAME_USB,
+        dlerror());
+        goto error;
+    }
+  } else {
+    lib_handle = dlopen(VENDOR_LIBRARY_NAME_UART,RTLD_NOW);
+    if (!lib_handle) {
+      ALOGE("%s unable to open %s: %s", __func__, VENDOR_LIBRARY_NAME_UART,
+      dlerror());
+      goto error;
+    }
+  }
+#else
   lib_handle = dlopen(VENDOR_LIBRARY_NAME, RTLD_NOW);
   if (!lib_handle) {
     LOG_ERROR(LOG_TAG, "%s unable to open %s: %s", __func__, VENDOR_LIBRARY_NAME, dlerror());
     goto error;
   }
+#endif
 
   lib_interface = (bt_vendor_interface_t *)dlsym(lib_handle, VENDOR_LIBRARY_SYMBOL_NAME);
   if (!lib_interface) {
@@ -64,7 +87,11 @@ static bool vendor_open(
 
   LOG_INFO(LOG_TAG, "alloc value %p", lib_callbacks.alloc);
 
+#ifdef BLUETOOTH_RTK
+  int status = lib_interface->init(&lib_callbacks, (unsigned char *)local_bdaddr,bt_hci_device_node);
+#else
   int status = lib_interface->init(&lib_callbacks, (unsigned char *)local_bdaddr);
+#endif
   if (status) {
     LOG_ERROR(LOG_TAG, "%s unable to initialize vendor library: %d", __func__, status);
     goto error;
diff --git a/include/stack_config.h b/include/stack_config.h
old mode 100644
new mode 100755
index b5278ce..d6375f0
--- a/include/stack_config.h
+++ b/include/stack_config.h
@@ -34,6 +34,10 @@ typedef struct {
   bool (*get_btsnoop_turned_on)(void);
   bool (*get_btsnoop_should_save_last)(void);
   bool (*get_trace_config_enabled)(void);
+#ifdef BLUETOOTH_RTK
+  int (*get_btsnoop_h5enable_log)(void);
+  int (*get_btsnoop_coexenable_log)(void);
+#endif
   bool (*get_pts_secure_only_mode)(void);
   bool (*get_pts_conn_updates_disabled)(void);
   bool (*get_pts_crosskey_sdp_disable)(void);
diff --git a/main/Android.mk b/main/Android.mk
old mode 100644
new mode 100755
index 25a0358..bda5dca
--- a/main/Android.mk
+++ b/main/Android.mk
@@ -99,6 +99,8 @@ LOCAL_REQUIRED_MODULES := \
     bt_did.conf \
     bt_stack.conf \
     libbt-hci \
+    libbt-vendor_uart \
+    libbt-vendor_usb \
     libbt-vendor
 
 LOCAL_CFLAGS += $(bluetooth_CFLAGS) -DBUILDCFG
diff --git a/main/bte_conf.c b/main/bte_conf.c
old mode 100644
new mode 100755
index 01d8071..630c754
--- a/main/bte_conf.c
+++ b/main/bte_conf.c
@@ -21,12 +21,150 @@
 #include <assert.h>
 #include <stdio.h>
 #include <string.h>
-
+#ifdef BLUETOOTH_RTK
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <sys/types.h>
+#endif
 #include "bta_api.h"
 #include "osi/include/compat.h"
 #include "osi/include/config.h"
 #include "osi/include/log.h"
+#ifdef BLUETOOTH_RTK
+#include "bt_hci_bdroid.h"
+#include "bdroid_buildcfg.h"
+extern char bt_hci_device_node[BT_HCI_DEVICE_NODE_MAX_LEN];
+extern bool bluetooth_rtk_h5_flag;
+#endif
+
+#ifdef BLUETOOTH_RTK
+
+#define USB_DEVICE_DIRECTORY  "/sys/bus/usb/devices"
+#define DEBUG_SCAN_USB     FALSE
+
+int Check_Key_Value(char* path,char* key,int value){
+    FILE *fp;
+    char newpath[100];
+    char string_get[6];
+    int value_int = 0;
+    memset(newpath,0,100);
+    sprintf(newpath,"%s/%s",path,key);
+    if((fp=fopen(newpath,"r"))!=NULL){
+        memset(string_get,0,6);
+        if(fgets(string_get,5,fp)!=NULL)
+            if(DEBUG_SCAN_USB)
+                ALOGE("string_get %s =%s\n",key,string_get);
+        fclose(fp);
+        value_int = strtol(string_get,NULL,16);
+        if(value_int == value)
+            return 1;
+    }
+    return 0;
+}
+
+int Scan_Usb_Devices_For_RTK(char* path){
+    char newpath[100];
+    char subpath[100];
+    DIR * pdir;
+    DIR * newpdir;
+    struct dirent * ptr;
+    struct dirent * newptr;
+    struct stat filestat;
+    struct stat subfilestat;
+    if(stat(path, &filestat) != 0){
+        ALOGE("The file or path(%s) can not be get stat!\n", newpath);
+        return -1;
+    }
+    if((filestat.st_mode & S_IFDIR) != S_IFDIR){
+        ALOGE("(%s) is not be a path!\n", path);
+        return -1;
+    }
+    pdir =opendir(path);
+    /*enter sub direc*/
+    while((ptr = readdir(pdir))!=NULL){
+        if(strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0)
+            continue;
+        memset(newpath,0,100);
+        sprintf(newpath,"%s/%s", path,ptr->d_name);
+        if(DEBUG_SCAN_USB)
+            ALOGE("The file or path(%s)\n", newpath);
+        if(stat(newpath, &filestat) != 0){
+            ALOGE("The file or path(%s) can not be get stat!\n", newpath);
+            continue;
+        }
+        /* Check if it is path. */
+        if((filestat.st_mode & S_IFDIR) == S_IFDIR){
+            if(!Check_Key_Value(newpath,"idVendor",0x0bda))
+                continue;
+            newpdir =opendir(newpath);
+            /*read sub directory*/
+            while((newptr = readdir(newpdir))!=NULL){
+                if(strcmp(newptr->d_name, ".") == 0 || strcmp(newptr->d_name, "..") == 0)
+                    continue;
+                memset(subpath,0,100);
+                sprintf(subpath,"%s/%s", newpath,newptr->d_name);
+                if(DEBUG_SCAN_USB)
+                    ALOGE("The file or path(%s)\n", subpath);
+                if(stat(subpath, &subfilestat) != 0){
+                    ALOGE("The file or path(%s) can not be get stat!\n", newpath);
+                    continue;
+                }
+                 /* Check if it is path. */
+                if((subfilestat.st_mode & S_IFDIR) == S_IFDIR){
+                    if(Check_Key_Value(subpath,"bInterfaceClass",0xe0) && \
+                        Check_Key_Value(subpath,"bInterfaceSubClass",0x01) && \
+                        Check_Key_Value(subpath,"bInterfaceProtocol",0x01)){
+                        closedir(newpdir);
+                        closedir(pdir);
+                        return 1;
+                    }
+                }
+            }
+            closedir(newpdir);
+        }
+    }
+    closedir(pdir);
+    return 0;
+}
 
+void bte_load_rtkbt_conf(const char *path)
+{
+    assert(path != NULL);
+
+    ALOGI("%s attempt to load rtkbt conf from %s",__func__, path);
+
+    config_t *config = config_new(path);
+    if (!config) {
+      ALOGI("%s file >%s< not found", __func__, path);
+      return;
+    }
+    memset(bt_hci_device_node, 0, sizeof(bt_hci_device_node));
+    /*0.check rtkbt.conf*/
+    strlcpy(bt_hci_device_node, config_get_string(config, CONFIG_DEFAULT_SECTION, "BtDeviceNode","/dev/rtk_btusb"), sizeof(bt_hci_device_node));
+    if(bt_hci_device_node[0]=='?'){
+        /*1.Scan_Usb_Device*/
+        if(Scan_Usb_Devices_For_RTK(USB_DEVICE_DIRECTORY) == 0x01)
+            strlcpy(bt_hci_device_node,"/dev/rtk_btusb", sizeof(bt_hci_device_node));
+        else{
+            int i = 0;
+            while(bt_hci_device_node[i]!= '\0'){
+                bt_hci_device_node[i] = bt_hci_device_node[i+1];
+                i++;
+            }
+        }
+    }
+    ALOGI("bt_hci_device_node   = %s \n",bt_hci_device_node);
+    config_free(config);
+    if(!strcmp(bt_hci_device_node, "/dev/rtk_btusb")){
+        bluetooth_rtk_h5_flag = FALSE;
+        LOG_INFO(LOG_TAG, "%s bluetooth_rtk_h5_flag :%d", __func__,bluetooth_rtk_h5_flag);
+    }else {
+        bluetooth_rtk_h5_flag = TRUE;
+    }
+}
+#endif
 // Parses the specified Device ID configuration file and registers the
 // Device ID records with SDP.
 void bte_load_did_conf(const char *p_path) {
diff --git a/main/bte_main.c b/main/bte_main.c
old mode 100644
new mode 100755
index da36056..801c4a9
--- a/main/bte_main.c
+++ b/main/bte_main.c
@@ -69,7 +69,11 @@
 #define BTE_BLE_STACK_CONF_FILE "/etc/bluetooth/ble_stack.conf"
 #endif  // defined(OS_GENERIC)
 #endif  // BT_BLE_STACK_CONF_FILE
-
+#ifdef BLUETOOTH_RTK
+#ifndef BTE_RTK_CONF_FILE
+#define BTE_RTK_CONF_FILE "/etc/bluetooth/rtkbt.conf"
+#endif
+#endif
 /******************************************************************************
 **  Variables
 ******************************************************************************/
@@ -88,6 +92,14 @@ static const hci_t *hci;
 *******************************************************************************/
 fixed_queue_t *btu_hci_msg_queue;
 
+#ifdef BLUETOOTH_RTK
+extern void bte_load_rtkbt_conf(const char *p_path);
+extern unsigned char h5_log_enable;
+static const stack_config_t *stack_config;
+#endif
+#ifdef BLUETOOTH_RTK_COEX
+extern unsigned char coex_log_enable;
+#endif
 /******************************************************************************
 **
 ** Function         bte_main_boot_entry
@@ -101,6 +113,10 @@ void bte_main_boot_entry(void)
 {
     module_init(get_module(INTEROP_MODULE));
 
+#ifdef BLUETOOTH_RTK
+    bte_load_rtkbt_conf(BTE_RTK_CONF_FILE);
+#endif
+
     hci = hci_layer_get_interface();
     if (!hci)
       LOG_ERROR(LOG_TAG, "%s could not get hci layer interface.", __func__);
@@ -115,6 +131,13 @@ void bte_main_boot_entry(void)
     hci->set_data_queue(btu_hci_msg_queue);
 
     module_init(get_module(STACK_CONFIG_MODULE));
+#ifdef BLUETOOTH_RTK
+    stack_config = stack_config_get_interface();
+    h5_log_enable = (uint8_t)stack_config->get_btsnoop_h5enable_log();
+#endif
+#ifdef BLUETOOTH_RTK_COEX
+    coex_log_enable = (uint8_t)stack_config->get_btsnoop_coexenable_log();
+#endif
 }
 
 /******************************************************************************
diff --git a/main/stack_config.c b/main/stack_config.c
old mode 100644
new mode 100755
index 109042f..f442245
--- a/main/stack_config.c
+++ b/main/stack_config.c
@@ -34,7 +34,13 @@ const char *PTS_LE_CONN_UPDATED_DISABLED = "PTS_DisableConnUpdates";
 const char *PTS_DISABLE_SDP_LE_PAIR = "PTS_DisableSDPOnLEPair";
 const char *PTS_SMP_PAIRING_OPTIONS_KEY = "PTS_SmpOptions";
 const char *PTS_SMP_FAILURE_CASE_KEY = "PTS_SmpFailureCase";
+#ifdef BLUETOOTH_RTK
+const char *BTSNOOP_H5_ENABLE_LOG = "H5LogOutput";
+#endif
 
+#ifdef BLUETOOTH_RTK_COEX
+const char *BTSNOOP_COEX_ENABLE_LOG = "BtCoexLogOutput";
+#endif
 static config_t *config;
 
 // Module lifecycle functions
@@ -93,6 +99,17 @@ static bool get_btsnoop_should_save_last(void) {
 static bool get_trace_config_enabled(void) {
   return config_get_bool(config, CONFIG_DEFAULT_SECTION, TRACE_CONFIG_ENABLED_KEY, false);
 }
+#ifdef BLUETOOTH_RTK
+static int get_btsnoop_h5enable_log(void) {
+     return config_get_int(config, CONFIG_DEFAULT_SECTION, BTSNOOP_H5_ENABLE_LOG, 0);
+}
+#endif
+
+#ifdef BLUETOOTH_RTK_COEX
+static int get_btsnoop_coexenable_log(void) {
+     return config_get_int(config, CONFIG_DEFAULT_SECTION, BTSNOOP_COEX_ENABLE_LOG, 0);
+}
+#endif
 
 static bool get_pts_secure_only_mode(void) {
     return config_get_bool(config, CONFIG_DEFAULT_SECTION, PTS_SECURE_ONLY_MODE, false);
@@ -123,6 +140,10 @@ const stack_config_t interface = {
   get_btsnoop_turned_on,
   get_btsnoop_should_save_last,
   get_trace_config_enabled,
+  #ifdef BLUETOOTH_RTK
+  get_btsnoop_h5enable_log,
+  get_btsnoop_coexenable_log,
+#endif
   get_pts_secure_only_mode,
   get_pts_conn_updates_disabled,
   get_pts_crosskey_sdp_disable,
diff --git a/stack/btm/btm_int.h b/stack/btm/btm_int.h
old mode 100644
new mode 100755
index 4bbc656..d4204e1
--- a/stack/btm/btm_int.h
+++ b/stack/btm/btm_int.h
@@ -42,7 +42,9 @@
 #include "smp_api.h"
 #endif
 #endif
-
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 #if BTM_MAX_LOC_BD_NAME_LEN > 0
 typedef char tBTM_LOC_BD_NAME[BTM_MAX_LOC_BD_NAME_LEN + 1];
 #endif
@@ -523,6 +525,9 @@ typedef struct
     LINK_KEY             link_key;          /* Device link key                    */
     UINT8                pin_code_length;   /* Length of the pin_code used for paring */
 
+#ifdef BLUETOOTH_RTK_COEX
+    UINT8                profile_map;       /* Profile_map For BT_Wifi Coex */
+#endif
 #define BTM_SEC_AUTHORIZED      BTM_SEC_FLAG_AUTHORIZED     /* 0x01 */
 #define BTM_SEC_AUTHENTICATED   BTM_SEC_FLAG_AUTHENTICATED  /* 0x02 */
 #define BTM_SEC_ENCRYPTED       BTM_SEC_FLAG_ENCRYPTED      /* 0x04 */
diff --git a/stack/btm/btm_sec.c b/stack/btm/btm_sec.c
old mode 100644
new mode 100755
index 83f6494..2365288
--- a/stack/btm/btm_sec.c
+++ b/stack/btm/btm_sec.c
@@ -38,6 +38,9 @@
 #include "hcimsgs.h"
 #include "l2c_int.h"
 
+#ifdef BLUETOOTH_RTK_COEX
+#include "rtk_parse.h"
+#endif
 #if (BT_USE_TRACES == TRUE && BT_TRACE_VERBOSE == FALSE)
 /* needed for sprintf() */
 #include <stdio.h>
@@ -4746,6 +4749,11 @@ void btm_sec_disconnected (UINT16 handle, UINT8 reason)
     if (!p_dev_rec)
         return;
 
+#ifdef BLUETOOTH_RTK_COEX
+    if ((p_dev_rec->device_type &= BT_DEVICE_TYPE_BLE) == 0x02) {
+        rtk_parse_manager_get_interface()->rtk_delete_le_profile(p_dev_rec->bd_addr, p_dev_rec->hci_handle, p_dev_rec->profile_map);
+    }
+#endif
     transport  = (handle == p_dev_rec->hci_handle) ? BT_TRANSPORT_BR_EDR: BT_TRANSPORT_LE;
 
     p_dev_rec->rs_disc_pending = BTM_SEC_RS_NOT_PENDING;     /* reset flag */
